{
  "total": 76,
  "p": 1,
  "ps": 500,
  "rules": [
    {
      "key": "csharpsquid:S2757",
      "repo": "csharpsquid",
      "name": "\"=+\" should not be used instead of \"+=\"",
      "createdAt": "2015-07-27T14:14:23+0200",
      "htmlDesc": "<p>The use of operators pairs ( <code>&#61;&#43;</code>, <code>&#61;-</code> or <code>&#61;!</code> ) where the reversed, single operator was meant (<code>&#43;&#61;</code>,\n<code>-&#61;</code> or <code>!&#61;</code>) will compile and run, but not produce the expected results.</p>\n<p>This rule raises an issue when <code>&#61;&#43;</code>, <code>&#61;-</code>, or <code>&#61;!</code> is used without any spacing between the two operators and when\nthere is at least one whitespace character after.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint target &#61; -5;\nint num &#61; 3;\n\ntarget &#61;- num;  // Noncompliant; target &#61; -3. Is that really what&#39;s meant?\ntarget &#61;&#43; num; // Noncompliant; target &#61; 3\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint target &#61; -5;\nint num &#61; 3;\n\ntarget &#61; -num;  // Compliant; intent to assign inverse value of num is clear\ntarget &#43;&#61; num;\n</pre>",
      "mdDesc": "<p>The use of operators pairs ( <code>=+</code>, <code>=-</code> or <code>=!</code> ) where the reversed, single operator was meant (<code>+=</code>,\n<code>-=</code> or <code>!=</code>) will compile and run, but not produce the expected results.</p>\n<p>This rule raises an issue when <code>=+</code>, <code>=-</code>, or <code>=!</code> is used without any spacing between the two operators and when\nthere is at least one whitespace character after.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint target = -5;\nint num = 3;\n\ntarget =- num;  // Noncompliant; target = -3. Is that really what's meant?\ntarget =+ num; // Noncompliant; target = 3\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint target = -5;\nint num = 3;\n\ntarget = -num;  // Compliant; intent to assign inverse value of num is clear\ntarget += num;\n</pre>",
      "severity": "MAJOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "2min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "2min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "2min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "2min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S3949",
      "repo": "csharpsquid",
      "name": "Calculations should not overflow",
      "createdAt": "2020-01-10T11:35:19+0100",
      "htmlDesc": "<p>Numbers are infinite, but the types that hold them are not. Each numeric type has hard upper and lower bounds. Try to calculate or assign numbers\nbeyond those bounds, and the result will be a value that has silently wrapped around from the expected positive value to a negative one, or vice\nversa.</p>\n<p>This rule is only available for analyses run on Windows machines. It will not be reported in analyses run on any other OS.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\npublic int getTheNumber(int val) {\n  if (val &lt;&#61; 0) {\n      return val;\n  }\n  int num &#61; int.MaxValue;\n  return num &#43; val;  // Noncompliant\n}\n</pre>",
      "mdDesc": "<p>Numbers are infinite, but the types that hold them are not. Each numeric type has hard upper and lower bounds. Try to calculate or assign numbers\nbeyond those bounds, and the result will be a value that has silently wrapped around from the expected positive value to a negative one, or vice\nversa.</p>\n<p>This rule is only available for analyses run on Windows machines. It will not be reported in analyses run on any other OS.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\npublic int getTheNumber(int val) {\n  if (val &lt;= 0) {\n      return val;\n  }\n  int num = int.MaxValue;\n  return num + val;  // Noncompliant\n}\n</pre>",
      "severity": "MAJOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [
        "overflow"
      ],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "5min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "5min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "5min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "5min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S2225",
      "repo": "csharpsquid",
      "name": "\"ToString()\" method should not return null",
      "createdAt": "2015-07-27T14:14:23+0200",
      "htmlDesc": "<p>Calling <code>ToString()</code> on an object should always return a string. Returning <code>null</code> instead contravenes the method’s implicit\ncontract.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\npublic override string ToString ()\n{\n  if (this.collection.Count &#61;&#61; 0)\n  {\n    return null; // Noncompliant\n  }\n  else\n  {\n    // ...\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\npublic override string ToString ()\n{\n  if (this.collection.Count &#61;&#61; 0)\n  {\n    return string.Empty;\n  }\n  else\n  {\n    // ...\n  }\n}\n</pre>\n<h2>See</h2>\n<ul><li> <a href=\"http://cwe.mitre.org/data/definitions/476.html\" rel=\"nofollow\">MITRE CWE-476</a> - NULL Pointer Dereference </li><li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/aDdGBQ\" rel=\"nofollow\">CERT, EXP01-J.</a> - Do not use a null in a case where an object is required </li></ul>",
      "mdDesc": "<p>Calling <code>ToString()</code> on an object should always return a string. Returning <code>null</code> instead contravenes the method’s implicit\ncontract.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\npublic override string ToString ()\n{\n  if (this.collection.Count == 0)\n  {\n    return null; // Noncompliant\n  }\n  else\n  {\n    // ...\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\npublic override string ToString ()\n{\n  if (this.collection.Count == 0)\n  {\n    return string.Empty;\n  }\n  else\n  {\n    // ...\n  }\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/476.html\">MITRE CWE-476</a> - NULL Pointer Dereference </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/aDdGBQ\">CERT, EXP01-J.</a> - Do not use a null in a case where an object is required </li>\n</ul>",
      "severity": "MAJOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [
        "cwe"
      ],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "5min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "5min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "5min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "5min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S2345",
      "repo": "csharpsquid",
      "name": "Flags enumerations should explicitly initialize all their members",
      "createdAt": "2015-12-08T16:59:59+0100",
      "htmlDesc": "<p>Flags enumerations should not rely on the language to initialize the values of their members. Implicit initialization will set the first member to\n0, and increment the value by one for each subsequent member. This implicit behavior does not allow members to be combined using the bitwise or\noperator in a useful way.</p>\n<p>Instead, 0 and powers of two (i.e. 1, 2, 4, 8, 16, …​) should be used to explicitly initialize all the members.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n[Flags]\nenum FruitType    // Noncompliant\n{\n  None,\n  Banana,\n  Orange,\n  Strawberry\n}\nclass Program\n{\n    static void Main()\n    {\n        var bananaAndStrawberry &#61; FruitType.Banana | FruitType.Strawberry;\n        // Will display only Strawberry!\n        Console.WriteLine(bananaAndStrawberry.ToString());\n    }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n[Flags]\nenum FruitType\n{\n  None &#61; 0,\n  Banana &#61; 1,\n  Orange &#61; 2,\n  Strawberry &#61; 4\n}\nclass Program\n{\n    static void Main()\n    {\n        var bananaAndStrawberry &#61; FruitType.Banana | FruitType.Strawberry;\n        // Will display Banana and Strawberry, as expected.\n        Console.WriteLine(bananaAndStrawberry.ToString());\n    }\n}\n</pre>\n<h2>Exceptions</h2>\n<p>The default initialization of 0, 1, 2, 3, 4, …​ matches 0, 1, 2, 4, 8 …​ in the first three values, so no issue is reported if the first three\nmembers of the enumeration is not initialized.</p>",
      "mdDesc": "<p>Flags enumerations should not rely on the language to initialize the values of their members. Implicit initialization will set the first member to\n0, and increment the value by one for each subsequent member. This implicit behavior does not allow members to be combined using the bitwise or\noperator in a useful way.</p>\n<p>Instead, 0 and powers of two (i.e. 1, 2, 4, 8, 16, …​) should be used to explicitly initialize all the members.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n[Flags]\nenum FruitType    // Noncompliant\n{\n  None,\n  Banana,\n  Orange,\n  Strawberry\n}\nclass Program\n{\n    static void Main()\n    {\n        var bananaAndStrawberry = FruitType.Banana | FruitType.Strawberry;\n        // Will display only Strawberry!\n        Console.WriteLine(bananaAndStrawberry.ToString());\n    }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n[Flags]\nenum FruitType\n{\n  None = 0,\n  Banana = 1,\n  Orange = 2,\n  Strawberry = 4\n}\nclass Program\n{\n    static void Main()\n    {\n        var bananaAndStrawberry = FruitType.Banana | FruitType.Strawberry;\n        // Will display Banana and Strawberry, as expected.\n        Console.WriteLine(bananaAndStrawberry.ToString());\n    }\n}\n</pre>\n<h2>Exceptions</h2>\n<p>The default initialization of 0, 1, 2, 3, 4, …​ matches 0, 1, 2, 4, 8 …​ in the first three values, so no issue is reported if the first three\nmembers of the enumeration is not initialized.</p>",
      "severity": "MINOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "5min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "5min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "5min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "5min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S2114",
      "repo": "csharpsquid",
      "name": "Collections should not be passed as arguments to their own methods",
      "createdAt": "2017-08-25T12:38:11+0200",
      "htmlDesc": "<p>Passing a collection as an argument to the collection’s own method is either an error - some other argument was intended - or simply nonsensical\ncode.</p>\n<p>Further, because some methods require that the argument remain unmodified during the execution, passing a collection to itself can result in an\nunexpected behavior.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvar list &#61; new List&lt;int&gt;();\n\nlist.AddRange(list); // Noncompliant\nlist.Concat(list); // Noncompliant\n\nlist.Union(list); // Noncompliant; always returns list\nlist.Except(list); // Noncompliant; always empty\nlist.Intersect(list); // Noncompliant; always list\nlist.SequenceEqual(list); // Noncompliant; always true\n\nvar set &#61; new HashSet&lt;int&gt;();\nset.UnionWith(set); // Noncompliant; no changes\nset.ExceptWith(set); // Noncompliant; always empty\nset.IntersectWith(set); // Noncompliant; no changes\nset.IsProperSubsetOf(set); // Noncompliant; always false\nset.IsProperSupersetOf(set); // Noncompliant; always false\nset.IsSubsetOf(set); // Noncompliant; always true\nset.IsSupersetOf(set); // Noncompliant; always true\nset.Overlaps(set); // Noncompliant; always true\nset.SetEquals(set); // Noncompliant; always true\nset.SymmetricExceptWith(set); // Noncompliant; always empty\n</pre>",
      "mdDesc": "<p>Passing a collection as an argument to the collection’s own method is either an error - some other argument was intended - or simply nonsensical\ncode.</p>\n<p>Further, because some methods require that the argument remain unmodified during the execution, passing a collection to itself can result in an\nunexpected behavior.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvar list = new List&lt;int&gt;();\n\nlist.AddRange(list); // Noncompliant\nlist.Concat(list); // Noncompliant\n\nlist.Union(list); // Noncompliant; always returns list\nlist.Except(list); // Noncompliant; always empty\nlist.Intersect(list); // Noncompliant; always list\nlist.SequenceEqual(list); // Noncompliant; always true\n\nvar set = new HashSet&lt;int&gt;();\nset.UnionWith(set); // Noncompliant; no changes\nset.ExceptWith(set); // Noncompliant; always empty\nset.IntersectWith(set); // Noncompliant; no changes\nset.IsProperSubsetOf(set); // Noncompliant; always false\nset.IsProperSupersetOf(set); // Noncompliant; always false\nset.IsSubsetOf(set); // Noncompliant; always true\nset.IsSupersetOf(set); // Noncompliant; always true\nset.Overlaps(set); // Noncompliant; always true\nset.SetEquals(set); // Noncompliant; always true\nset.SymmetricExceptWith(set); // Noncompliant; always empty\n</pre>",
      "severity": "MAJOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "15min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "15min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "15min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "15min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S3449",
      "repo": "csharpsquid",
      "name": "Right operands of shift operators should be integers",
      "createdAt": "2016-03-04T14:35:13+0100",
      "htmlDesc": "<p>Numbers can be shifted with the <code>&lt;&lt;</code> and <code>&gt;&gt;</code> operators, but the right operand of the operation needs to be an\n<code>int</code> or a type that has an implicit conversion to <code>int</code>. However, with <code>dynamic</code>, the compiler’s type checking is\nturned off, so you can pass anything to a shift operator and have it compile. And if the argument can’t be converted to <code>int</code> at runtime,\nthen a <code>RuntimeBinderException</code> will be raised.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\ndynamic d &#61; 5;\nvar x &#61; d &gt;&gt; 5.4; // Noncompliant\nx &#61; d &gt;&gt; null; // Noncompliant\nx &lt;&lt;&#61; new object(); // Noncompliant\n</pre>",
      "mdDesc": "<p>Numbers can be shifted with the <code>&lt;&lt;</code> and <code>&gt;&gt;</code> operators, but the right operand of the operation needs to be an\n<code>int</code> or a type that has an implicit conversion to <code>int</code>. However, with <code>dynamic</code>, the compiler’s type checking is\nturned off, so you can pass anything to a shift operator and have it compile. And if the argument can’t be converted to <code>int</code> at runtime,\nthen a <code>RuntimeBinderException</code> will be raised.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\ndynamic d = 5;\nvar x = d &gt;&gt; 5.4; // Noncompliant\nx = d &gt;&gt; null; // Noncompliant\nx &lt;&lt;= new object(); // Noncompliant\n</pre>",
      "severity": "CRITICAL",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "10min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "10min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "10min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "10min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S2688",
      "repo": "csharpsquid",
      "name": "\"NaN\" should not be used in comparisons",
      "createdAt": "2017-02-03T13:58:45+0100",
      "htmlDesc": "<p><code>NaN</code> is not equal to anything, even itself. Testing for equality or inequality against <code>NaN</code> will yield predictable results,\nbut probably not the ones you want.</p>\n<p>Instead, the best way to see whether a variable is equal to <code>NaN</code> is to use <code>Number.isNaN()</code>, since ES2015, or (perhaps\ncounter-intuitively) to compare it to itself. Since <code>NaN !&#61;&#61; NaN</code>, when <code>a !&#61;&#61; a</code>, you know it must equal <code>NaN</code>.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvar a &#61; double.NaN;\n\nif (a &#61;&#61; double.NaN) // Noncompliant; always false\n{\n  Console.WriteLine(&#34;a is not a number&#34;);  // this is dead code\n}\nif (a !&#61; double.NaN)  // Noncompliant; always true\n{\n  Console.WriteLine(&#34;a is not NaN&#34;); // this statement is not necessarily true\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nif (double.IsNaN(a))\n{\n  console.log(&#34;a is not a number&#34;);\n}\n</pre>\n<h2>See</h2>\n<ul><li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/wzdGBQ\" rel=\"nofollow\">CERT, NUM07-J.</a> - Do not attempt comparisons with NaN </li></ul>",
      "mdDesc": "<p><code>NaN</code> is not equal to anything, even itself. Testing for equality or inequality against <code>NaN</code> will yield predictable results,\nbut probably not the ones you want.</p>\n<p>Instead, the best way to see whether a variable is equal to <code>NaN</code> is to use <code>Number.isNaN()</code>, since ES2015, or (perhaps\ncounter-intuitively) to compare it to itself. Since <code>NaN !== NaN</code>, when <code>a !== a</code>, you know it must equal <code>NaN</code>.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvar a = double.NaN;\n\nif (a == double.NaN) // Noncompliant; always false\n{\n  Console.WriteLine(\"a is not a number\");  // this is dead code\n}\nif (a != double.NaN)  // Noncompliant; always true\n{\n  Console.WriteLine(\"a is not NaN\"); // this statement is not necessarily true\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nif (double.IsNaN(a))\n{\n  console.log(\"a is not a number\");\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/wzdGBQ\">CERT, NUM07-J.</a> - Do not attempt comparisons with NaN </li>\n</ul>",
      "severity": "MAJOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "5min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "5min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "5min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "5min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S2201",
      "repo": "csharpsquid",
      "name": "Return values from functions without side effects should not be ignored",
      "createdAt": "2016-04-29T16:35:29+0200",
      "htmlDesc": "<p>When the call to a function doesn’t have any side effects, what is the point of making the call if the results are ignored? In such case, either\nthe function call is useless and should be dropped or the source code doesn’t behave as expected.</p>\n<p>This rule raises an issue when the results of the following methods are ignored:</p>\n<ul><li> LINQ method, </li><li> <code>[Pure]</code> method, </li><li> any method on <code>string</code>, <code>int</code>, …​, <code>System.Collections.Immutable.ImmutableArray&lt;T&gt;</code>,\n  <code>ImmutableHashSet&lt;T&gt;</code>, …​ </li></ul>\n<p>Notes:</p>\n<ul><li> although <code>string.Intern</code> has a side effect, ignoring its return value is still suspicious as it is the only reference ensured to\n  point to the intern pool. </li><li> Link methods can have side effects if they are misused. Example: </li></ul>\n<pre>\ntests.All(c &#61;&gt; { c.myfield &#61; &#34;foo&#34;; return true; });\n</pre>\n<p>Such code should be rewritten as a normal loop.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\ncoll.Where(i &#61;&gt; i &gt; 5).Select(i &#61;&gt; i*i); // Noncompliant\n&#34;this string&#34;.Equals(&#34;other string&#34;); // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvar res &#61; coll.Where(i &#61;&gt; i &gt; 5).Select(i &#61;&gt; i*i);\nvar isEqual &#61; &#34;this string&#34;.Equals(&#34;other string&#34;);\n</pre>\n<h2>Exceptions</h2>\n<p>This rule doesn’t report issues on method calls with <code>out</code> or <code>ref</code> arguments.</p>\n<h2>See</h2>\n<ul><li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/mtYxBQ\" rel=\"nofollow\">CERT, EXP12-C.</a> - Do not ignore values returned by functions </li><li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/xzdGBQ\" rel=\"nofollow\">CERT, EXP00-J.</a> - Do not ignore values returned by methods </li></ul>",
      "mdDesc": "<p>When the call to a function doesn’t have any side effects, what is the point of making the call if the results are ignored? In such case, either\nthe function call is useless and should be dropped or the source code doesn’t behave as expected.</p>\n<p>This rule raises an issue when the results of the following methods are ignored:</p>\n<ul>\n  <li> LINQ method, </li>\n  <li> <code>[Pure]</code> method, </li>\n  <li> any method on <code>string</code>, <code>int</code>, …​, <code>System.Collections.Immutable.ImmutableArray&lt;T&gt;</code>,\n  <code>ImmutableHashSet&lt;T&gt;</code>, …​ </li>\n</ul>\n<p>Notes:</p>\n<ul>\n  <li> although <code>string.Intern</code> has a side effect, ignoring its return value is still suspicious as it is the only reference ensured to\n  point to the intern pool. </li>\n  <li> Link methods can have side effects if they are misused. Example: </li>\n</ul>\n<pre>\ntests.All(c =&gt; { c.myfield = \"foo\"; return true; });\n</pre>\n<p>Such code should be rewritten as a normal loop.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\ncoll.Where(i =&gt; i &gt; 5).Select(i =&gt; i*i); // Noncompliant\n\"this string\".Equals(\"other string\"); // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvar res = coll.Where(i =&gt; i &gt; 5).Select(i =&gt; i*i);\nvar isEqual = \"this string\".Equals(\"other string\");\n</pre>\n<h2>Exceptions</h2>\n<p>This rule doesn’t report issues on method calls with <code>out</code> or <code>ref</code> arguments.</p>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/mtYxBQ\">CERT, EXP12-C.</a> - Do not ignore values returned by functions </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/xzdGBQ\">CERT, EXP00-J.</a> - Do not ignore values returned by methods </li>\n</ul>",
      "severity": "MAJOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "10min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "10min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "10min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "10min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S3598",
      "repo": "csharpsquid",
      "name": "One-way \"OperationContract\" methods should have \"void\" return type",
      "createdAt": "2016-05-25T15:32:27+0200",
      "htmlDesc": "<p>When declaring a Windows Communication Foundation (WCF) <code>OperationContract</code> method one-way, that service method won’t return any result,\nnot even an underlying empty confirmation message. These are fire-and-forget methods that are useful in event-like communication. Specifying a return\ntype therefore does not make sense.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n[ServiceContract]\ninterface IMyService\n{\n  [OperationContract(IsOneWay &#61; true)]\n  int SomethingHappened(int parameter); // Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n[ServiceContract]\ninterface IMyService\n{\n  [OperationContract(IsOneWay &#61; true)]\n  void SomethingHappened(int parameter);\n}\n</pre>\n<h2>Exceptions</h2>\n<p>The rule doesn’t report if <code>OperationContractAttribute.AsyncPattern</code> is set to <code>true</code>.</p>",
      "mdDesc": "<p>When declaring a Windows Communication Foundation (WCF) <code>OperationContract</code> method one-way, that service method won’t return any result,\nnot even an underlying empty confirmation message. These are fire-and-forget methods that are useful in event-like communication. Specifying a return\ntype therefore does not make sense.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n[ServiceContract]\ninterface IMyService\n{\n  [OperationContract(IsOneWay = true)]\n  int SomethingHappened(int parameter); // Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n[ServiceContract]\ninterface IMyService\n{\n  [OperationContract(IsOneWay = true)]\n  void SomethingHappened(int parameter);\n}\n</pre>\n<h2>Exceptions</h2>\n<p>The rule doesn’t report if <code>OperationContractAttribute.AsyncPattern</code> is set to <code>true</code>.</p>",
      "severity": "MAJOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "15min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "15min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "15min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "15min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S3249",
      "repo": "csharpsquid",
      "name": "Classes directly extending \"object\" should not call \"base\" in \"GetHashCode\" or \"Equals\"",
      "createdAt": "2015-10-02T13:39:15+0200",
      "htmlDesc": "<p>Making a <code>base</code> call in an overriding method is generally a good idea, but not in <code>GetHashCode</code> and <code>Equals</code> for\nclasses that directly extend <code>object</code> because those methods are based on the object reference. Meaning that no two <code>objects</code>\nthat use those <code>base</code> methods will ever be equal or have the same hash.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\npublic class Point\n{\n  private readonly int x;\n  public MyClass(int x)\n  {\n    this.x &#61; x;\n  }\n  public override int GetHashCode()\n  {\n    return x.GetHashCode() ^ base.GetHashCode(); //Noncompliant\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\npublic class Point\n{\n  private readonly int x;\n  public MyClass(int x)\n  {\n    this.x &#61; x;\n  }\n  public override int GetHashCode()\n  {\n    return x.GetHashCode();\n  }\n}\n</pre>\n<h2>Exceptions</h2>\n<p>This rule doesn’t report on guard conditions checking for reference equality.</p>\n<pre>\npublic class Point\n{\n  public override bool Equals(object obj)\n  {\n    if (base.Equals(obj)) // Compliant, although it could be replaced with object.ReferenceEquals(obj, this), which is clearer\n    {\n      return true;\n    }\n    ...\n  }\n}\n</pre>",
      "mdDesc": "<p>Making a <code>base</code> call in an overriding method is generally a good idea, but not in <code>GetHashCode</code> and <code>Equals</code> for\nclasses that directly extend <code>object</code> because those methods are based on the object reference. Meaning that no two <code>objects</code>\nthat use those <code>base</code> methods will ever be equal or have the same hash.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\npublic class Point\n{\n  private readonly int x;\n  public MyClass(int x)\n  {\n    this.x = x;\n  }\n  public override int GetHashCode()\n  {\n    return x.GetHashCode() ^ base.GetHashCode(); //Noncompliant\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\npublic class Point\n{\n  private readonly int x;\n  public MyClass(int x)\n  {\n    this.x = x;\n  }\n  public override int GetHashCode()\n  {\n    return x.GetHashCode();\n  }\n}\n</pre>\n<h2>Exceptions</h2>\n<p>This rule doesn’t report on guard conditions checking for reference equality.</p>\n<pre>\npublic class Point\n{\n  public override bool Equals(object obj)\n  {\n    if (base.Equals(obj)) // Compliant, although it could be replaced with object.ReferenceEquals(obj, this), which is clearer\n    {\n      return true;\n    }\n    ...\n  }\n}\n</pre>",
      "severity": "MAJOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "15min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "15min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "15min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "15min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S3005",
      "repo": "csharpsquid",
      "name": "\"ThreadStatic\" should not be used on non-static fields",
      "createdAt": "2015-07-27T14:14:23+0200",
      "htmlDesc": "<p>When a non-<code>static</code> class field is annotated with <code>ThreadStatic</code>, the code seems to show that the field can have different\nvalues for different calling threads, but that’s not the case, since the <code>ThreadStatic</code> attribute is simply ignored on\nnon-<code>static</code> fields.</p>\n<p>So <code>ThreadStatic</code> should either be removed or replaced with a use of the <code>ThreadLocal&lt;T&gt;</code> class, which gives a similar\nbehavior for non-<code>static</code> fields.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\npublic class MyClass\n{\n  [ThreadStatic]  // Noncompliant\n  private int count &#61; 0;\n\n  // ...\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\npublic class MyClass\n{\n  private int count &#61; 0;\n\n  // ...\n}\n</pre>\n<p>or</p>\n<pre>\npublic class MyClass\n{\n  private readonly ThreadLocal&lt;int&gt; count &#61; new ThreadLocal&lt;int&gt;();\n  public int Count\n  {\n    get { return count.Value; }\n    set { count.Value &#61; value; }\n  }\n  // ...\n}\n</pre>",
      "mdDesc": "<p>When a non-<code>static</code> class field is annotated with <code>ThreadStatic</code>, the code seems to show that the field can have different\nvalues for different calling threads, but that’s not the case, since the <code>ThreadStatic</code> attribute is simply ignored on\nnon-<code>static</code> fields.</p>\n<p>So <code>ThreadStatic</code> should either be removed or replaced with a use of the <code>ThreadLocal&lt;T&gt;</code> class, which gives a similar\nbehavior for non-<code>static</code> fields.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\npublic class MyClass\n{\n  [ThreadStatic]  // Noncompliant\n  private int count = 0;\n\n  // ...\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\npublic class MyClass\n{\n  private int count = 0;\n\n  // ...\n}\n</pre>\n<p>or</p>\n<pre>\npublic class MyClass\n{\n  private readonly ThreadLocal&lt;int&gt; count = new ThreadLocal&lt;int&gt;();\n  public int Count\n  {\n    get { return count.Value; }\n    set { count.Value = value; }\n  }\n  // ...\n}\n</pre>",
      "severity": "MAJOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [
        "unused"
      ],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "5min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "5min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "5min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "5min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S3244",
      "repo": "csharpsquid",
      "name": "Anonymous delegates should not be used to unsubscribe from Events",
      "createdAt": "2015-10-02T13:39:15+0200",
      "htmlDesc": "<p>It is possible to subscribe to events with anonymous delegates, but having done so, it is impossible to unsubscribe from them. That’s because the\nprocess of subscribing adds the delegate to a list. The process of unsubscribing essentially says: remove <em>this item</em> from the subscription\nlist. But because an anonymous delegate was used in both cases, the unsubscribe attempt tries to remove a different item from the list than was added.\nThe result: <code>NOOP</code>.</p>\n<p>Instead, save the delegate to a variable and use the variable to subscribe and unsubscribe.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nlistView.PreviewTextInput &#43;&#61; (obj,args) &#61;&gt;\n        listView_PreviewTextInput(obj,args,listView);\n\n// ...\n\nlistView.PreviewTextInput -&#61; (obj, args) &#61;&gt;\n        listView_PreviewTextInput(obj, args, listView); // Noncompliant; this delegate was never subscribed\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nEventHandler func &#61; (obj,args) &#61;&gt; listView_PreviewTextInput(obj,args,listView);\n\nlistView.PreviewTextInput &#43;&#61; func;\n\n// ...\n\nlistView.PreviewTextInput -&#61; func;\n</pre>",
      "mdDesc": "<p>It is possible to subscribe to events with anonymous delegates, but having done so, it is impossible to unsubscribe from them. That’s because the\nprocess of subscribing adds the delegate to a list. The process of unsubscribing essentially says: remove <em>this item</em> from the subscription\nlist. But because an anonymous delegate was used in both cases, the unsubscribe attempt tries to remove a different item from the list than was added.\nThe result: <code>NOOP</code>.</p>\n<p>Instead, save the delegate to a variable and use the variable to subscribe and unsubscribe.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nlistView.PreviewTextInput += (obj,args) =&gt;\n        listView_PreviewTextInput(obj,args,listView);\n\n// ...\n\nlistView.PreviewTextInput -= (obj, args) =&gt;\n        listView_PreviewTextInput(obj, args, listView); // Noncompliant; this delegate was never subscribed\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nEventHandler func = (obj,args) =&gt; listView_PreviewTextInput(obj,args,listView);\n\nlistView.PreviewTextInput += func;\n\n// ...\n\nlistView.PreviewTextInput -= func;\n</pre>",
      "severity": "MAJOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "15min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "15min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "15min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "15min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S2275",
      "repo": "csharpsquid",
      "name": "Composite format strings should not lead to unexpected behavior at runtime",
      "createdAt": "2015-11-03T15:27:00+0100",
      "htmlDesc": "<p>Because composite format strings are interpreted at runtime, rather than validated by the compiler, they can contain errors that lead to unexpected\nbehaviors or runtime errors. This rule statically validates the good behavior of composite formats when calling the methods of\n<code>String.Format</code>, <code>StringBuilder.AppendFormat</code>, <code>Console.Write</code>, <code>Console.WriteLine</code>,\n<code>TextWriter.Write</code>, <code>TextWriter.WriteLine</code>, <code>Debug.WriteLine(String, Object[])</code>,\n<code>Trace.TraceError(String, Object[])</code>, <code>Trace.TraceInformation(String, Object[])</code>,\n<code>Trace.TraceWarning(String, Object[])</code> and <code>TraceSource.TraceInformation(String, Object[])</code>.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\ns &#61; string.Format(&#34;[0}&#34;, arg0);\ns &#61; string.Format(&#34;{<!-- -->{0}&#34;, arg0);\ns &#61; string.Format(&#34;{0}}&#34;, arg0);\ns &#61; string.Format(&#34;{-1}&#34;, arg0);\ns &#61; string.Format(&#34;{0} {1}&#34;, arg0);\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\ns &#61; string.Format(&#34;{0}&#34;, 42); // Compliant\ns &#61; string.Format(&#34;{0,10}&#34;, 42); // Compliant\ns &#61; string.Format(&#34;{0,-10}&#34;, 42); // Compliant\ns &#61; string.Format(&#34;{0:0000}&#34;, 42); // Compliant\ns &#61; string.Format(&#34;{2}-{0}-{1}&#34;, 1, 2, 3); // Compliant\ns &#61; string.Format(&#34;no format&#34;); // Compliant\n</pre>\n<h2>Exceptions</h2>\n<ul><li> No issue is raised if the format string is not a <code>const</code>. </li></ul>\n<pre>\nvar pattern &#61; &#34;{0} {1} {2}&#34;;\nvar res &#61; string.Format(pattern, 1, 2); // Compliant, not const string are not recognized\n</pre>\n<ul><li> No issue is raised if the argument is not an inline creation array. </li></ul>\n<pre>\nvar array &#61; new int[] {};\nvar res &#61; string.Format(&#34;{0} {1}&#34;, array); // Compliant we don&#39;t know the size of the array\n</pre>\n<ul><li> This rule doesn’t check whether the format specifier (defined after the <code>:</code>) is actually valid. </li></ul>\n<h2>See</h2>\n<ul><li> <a href=\"https://www.securecoding.cert.org/confluence/x/wQA1\" rel=\"nofollow\">CERT, FIO47-C.</a> - Use valid format strings </li></ul>",
      "mdDesc": "<p>Because composite format strings are interpreted at runtime, rather than validated by the compiler, they can contain errors that lead to unexpected\nbehaviors or runtime errors. This rule statically validates the good behavior of composite formats when calling the methods of\n<code>String.Format</code>, <code>StringBuilder.AppendFormat</code>, <code>Console.Write</code>, <code>Console.WriteLine</code>,\n<code>TextWriter.Write</code>, <code>TextWriter.WriteLine</code>, <code>Debug.WriteLine(String, Object[])</code>,\n<code>Trace.TraceError(String, Object[])</code>, <code>Trace.TraceInformation(String, Object[])</code>,\n<code>Trace.TraceWarning(String, Object[])</code> and <code>TraceSource.TraceInformation(String, Object[])</code>.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\ns = string.Format(\"[0}\", arg0);\ns = string.Format(\"{{0}\", arg0);\ns = string.Format(\"{0}}\", arg0);\ns = string.Format(\"{-1}\", arg0);\ns = string.Format(\"{0} {1}\", arg0);\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\ns = string.Format(\"{0}\", 42); // Compliant\ns = string.Format(\"{0,10}\", 42); // Compliant\ns = string.Format(\"{0,-10}\", 42); // Compliant\ns = string.Format(\"{0:0000}\", 42); // Compliant\ns = string.Format(\"{2}-{0}-{1}\", 1, 2, 3); // Compliant\ns = string.Format(\"no format\"); // Compliant\n</pre>\n<h2>Exceptions</h2>\n<ul>\n  <li> No issue is raised if the format string is not a <code>const</code>. </li>\n</ul>\n<pre>\nvar pattern = \"{0} {1} {2}\";\nvar res = string.Format(pattern, 1, 2); // Compliant, not const string are not recognized\n</pre>\n<ul>\n  <li> No issue is raised if the argument is not an inline creation array. </li>\n</ul>\n<pre>\nvar array = new int[] {};\nvar res = string.Format(\"{0} {1}\", array); // Compliant we don't know the size of the array\n</pre>\n<ul>\n  <li> This rule doesn’t check whether the format specifier (defined after the <code>:</code>) is actually valid. </li>\n</ul>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://www.securecoding.cert.org/confluence/x/wQA1\">CERT, FIO47-C.</a> - Use valid format strings </li>\n</ul>",
      "severity": "BLOCKER",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "10min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "10min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "10min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "10min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S3453",
      "repo": "csharpsquid",
      "name": "Classes should not have only \"private\" constructors",
      "createdAt": "2016-04-29T16:35:29+0200",
      "htmlDesc": "<p>A class with only <code>private</code> constructors can’t be instantiated, thus, it seems to be pointless code.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\npublic class MyClass // Noncompliant\n{\n  private MyClass() { ... }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\npublic class MyClass\n{\n  public MyClass() { ... }\n}\n</pre>\n<h2>Exceptions</h2>\n<p>Classes that themselves access their private constructors (singletons or smart enums) are ignored. Classes with only <code>static</code> members\nare also ignored because they are covered by Rule <a href=\"/organizations/explore/rules?open&#61;csharpsquid%3AS1118&amp;rule_key&#61;csharpsquid%3AS1118\" rel=\"nofollow\">S1118</a>.</p>",
      "mdDesc": "<p>A class with only <code>private</code> constructors can’t be instantiated, thus, it seems to be pointless code.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\npublic class MyClass // Noncompliant\n{\n  private MyClass() { ... }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\npublic class MyClass\n{\n  public MyClass() { ... }\n}\n</pre>\n<h2>Exceptions</h2>\n<p>Classes that themselves access their private constructors (singletons or smart enums) are ignored. Classes with only <code>static</code> members\nare also ignored because they are covered by Rule {rule:csharpsquid:S1118}.</p>",
      "severity": "MAJOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [
        "design"
      ],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "5min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "5min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "5min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "5min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S4428",
      "repo": "csharpsquid",
      "name": "\"PartCreationPolicyAttribute\" should be used with \"ExportAttribute\"",
      "createdAt": "2018-03-12T12:55:37+0100",
      "htmlDesc": "<p>The <code>PartCreationPolicyAttribute</code> attribute, which is part of the Managed Extensibility Framework (MEF), is used to specify how the\nexported object will be created. Therefore it doesn’t make sense not to export this a class with this attribute using the <code>ExportAttribute</code>\nattribute.</p>\n<p>This rule raises an issue when a class is marked as shared with a <code>PartCreationPolicyAttribute</code> but lacks a\n<code>ExportAttribute</code>.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n[PartCreationPolicy(CreationPolicy.Any)] // Noncompliant\npublic class FooBar : IFooBar\n{\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n[Export(typeof(IFooBar))]\n[PartCreationPolicy(CreationPolicy.Any)]\npublic class FooBar : IFooBar\n{\n}\n</pre>",
      "mdDesc": "<p>The <code>PartCreationPolicyAttribute</code> attribute, which is part of the Managed Extensibility Framework (MEF), is used to specify how the\nexported object will be created. Therefore it doesn’t make sense not to export this a class with this attribute using the <code>ExportAttribute</code>\nattribute.</p>\n<p>This rule raises an issue when a class is marked as shared with a <code>PartCreationPolicyAttribute</code> but lacks a\n<code>ExportAttribute</code>.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n[PartCreationPolicy(CreationPolicy.Any)] // Noncompliant\npublic class FooBar : IFooBar\n{\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n[Export(typeof(IFooBar))]\n[PartCreationPolicy(CreationPolicy.Any)]\npublic class FooBar : IFooBar\n{\n}\n</pre>",
      "severity": "MAJOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [
        "mef",
        "pitfall"
      ],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "5min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "5min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "5min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "5min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S3466",
      "repo": "csharpsquid",
      "name": "Optional parameters should be passed to \"base\" calls",
      "createdAt": "2016-03-04T14:35:13+0100",
      "htmlDesc": "<p>Generally, writing the least code that will <em>readably</em> do the job is a good thing, so omitting default parameter values seems to make sense.\nUnfortunately, when you omit them from the <code>base</code> call in an override, you’re not actually getting the job done thoroughly, because you’re\nignoring the value the caller passed in. The result will likely not be what the caller expected.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\npublic class BaseClass\n{\n    public virtual void MyMethod(int i &#61; 1)\n    {\n        Console.WriteLine(i);\n    }\n}\n\npublic class DerivedClass : BaseClass\n{\n    public override void MyMethod(int i &#61; 1)\n    {\n        // ...\n        base.MyMethod(); // Noncompliant; caller&#39;s value is ignored\n    }\n\n    static int Main(string[] args)\n    {\n        DerivedClass dc &#61; new DerivedClass();\n        dc.MyMethod(12);  // prints 1\n    }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\npublic class BaseClass\n{\n    public virtual void MyMethod(int i &#61; 1)\n    {\n        Console.WriteLine(i);\n    }\n}\n\npublic class DerivedClass : BaseClass\n{\n    public override void MyMethod(int i &#61; 1)\n    {\n        // ...\n        base.MyMethod(i);\n    }\n\n    static int Main(string[] args)\n    {\n        DerivedClass dc &#61; new DerivedClass();\n        dc.MyMethod(12);  // prints 12\n    }\n}\n</pre>",
      "mdDesc": "<p>Generally, writing the least code that will <em>readably</em> do the job is a good thing, so omitting default parameter values seems to make sense.\nUnfortunately, when you omit them from the <code>base</code> call in an override, you’re not actually getting the job done thoroughly, because you’re\nignoring the value the caller passed in. The result will likely not be what the caller expected.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\npublic class BaseClass\n{\n    public virtual void MyMethod(int i = 1)\n    {\n        Console.WriteLine(i);\n    }\n}\n\npublic class DerivedClass : BaseClass\n{\n    public override void MyMethod(int i = 1)\n    {\n        // ...\n        base.MyMethod(); // Noncompliant; caller's value is ignored\n    }\n\n    static int Main(string[] args)\n    {\n        DerivedClass dc = new DerivedClass();\n        dc.MyMethod(12);  // prints 1\n    }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\npublic class BaseClass\n{\n    public virtual void MyMethod(int i = 1)\n    {\n        Console.WriteLine(i);\n    }\n}\n\npublic class DerivedClass : BaseClass\n{\n    public override void MyMethod(int i = 1)\n    {\n        // ...\n        base.MyMethod(i);\n    }\n\n    static int Main(string[] args)\n    {\n        DerivedClass dc = new DerivedClass();\n        dc.MyMethod(12);  // prints 12\n    }\n}\n</pre>",
      "severity": "MAJOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "5min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "5min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "5min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "5min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S3346",
      "repo": "csharpsquid",
      "name": "Expressions used in \"Debug.Assert\" should not produce side effects",
      "createdAt": "2017-06-22T07:35:07+0200",
      "htmlDesc": "<p>An assertion is a piece of code that’s used during development when the compilation debug mode is activated. It allows a program to check itself as\nit runs. When an assertion is true, that means everything is operating as expected.</p>\n<p>In non-debug mode, all <code>Debug.Assert</code> are automatically left out. So, by contract, the boolean expressions that are evaluated by those\nassertions must absolutely not contain any side effects. Otherwise, when leaving the Debug mode, the functional behavior of the application is not the\nsame anymore.</p>\n<p>The rule will raise if the method name starts with any of the following <code>remove</code>, <code>delete</code>, <code>add</code>,\n<code>pop</code>, <code>update</code>, <code>retain</code>, <code>insert</code>, <code>push</code>, <code>append</code>, <code>clear</code>,\n<code>dequeue</code>, <code>enqueue</code>, <code>dispose</code>, <code>put</code>, or <code>set</code>, although <code>SetEquals</code> will be\nignored.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nDebug.Assert(list.Remove(&#34;dog&#34;));\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nbool result &#61; list.Remove(&#34;dog&#34;);\nDebug.Assert(result);\n</pre>\n<h2>See</h2>\n<ul><li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/mjdGBQ\" rel=\"nofollow\">CERT, EXP06-J.</a> - Expressions used in assertions must not produce side effects </li></ul>",
      "mdDesc": "<p>An assertion is a piece of code that’s used during development when the compilation debug mode is activated. It allows a program to check itself as\nit runs. When an assertion is true, that means everything is operating as expected.</p>\n<p>In non-debug mode, all <code>Debug.Assert</code> are automatically left out. So, by contract, the boolean expressions that are evaluated by those\nassertions must absolutely not contain any side effects. Otherwise, when leaving the Debug mode, the functional behavior of the application is not the\nsame anymore.</p>\n<p>The rule will raise if the method name starts with any of the following <code>remove</code>, <code>delete</code>, <code>add</code>,\n<code>pop</code>, <code>update</code>, <code>retain</code>, <code>insert</code>, <code>push</code>, <code>append</code>, <code>clear</code>,\n<code>dequeue</code>, <code>enqueue</code>, <code>dispose</code>, <code>put</code>, or <code>set</code>, although <code>SetEquals</code> will be\nignored.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nDebug.Assert(list.Remove(\"dog\"));\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nbool result = list.Remove(\"dog\");\nDebug.Assert(result);\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/mjdGBQ\">CERT, EXP06-J.</a> - Expressions used in assertions must not produce side effects </li>\n</ul>",
      "severity": "MAJOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "5min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "5min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "5min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "5min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S3343",
      "repo": "csharpsquid",
      "name": "Caller information parameters should come at the end of the parameter list",
      "createdAt": "2018-02-14T07:15:14+0100",
      "htmlDesc": "<p>Caller information attributes (<code>CallerFilePathAttribute</code>, <code>CallerLineNumberAttribute</code>, and\n<code>CallerMemberNameAttribute</code>) provide a way to get information about the caller of a method through optional parameters. But they only work\nright if their values aren’t provided explicitly. So if you define a method with caller info attributes in the middle of the parameter list, you put\nyour callers in a bad position: they are forced to use named arguments if they want to use the method properly.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid TraceMessage([CallerMemberName] string memberName &#61; &#34;&#34;,\n  [CallerFilePath] string filePath &#61; &#34;&#34;,\n  [CallerLineNumber] int lineNumber &#61; 0,\n  string message &#61; null)  // Noncompliant\n{\n  /* ... */\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid TraceMessage(string message &#61; null,\n  [CallerMemberName] string memberName &#61; &#34;&#34;,\n  [CallerFilePath] string filePath &#61; &#34;&#34;,\n  [CallerLineNumber] int lineNumber &#61; 0)\n{\n  /* ... */\n}\n</pre>",
      "mdDesc": "<p>Caller information attributes (<code>CallerFilePathAttribute</code>, <code>CallerLineNumberAttribute</code>, and\n<code>CallerMemberNameAttribute</code>) provide a way to get information about the caller of a method through optional parameters. But they only work\nright if their values aren’t provided explicitly. So if you define a method with caller info attributes in the middle of the parameter list, you put\nyour callers in a bad position: they are forced to use named arguments if they want to use the method properly.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvoid TraceMessage([CallerMemberName] string memberName = \"\",\n  [CallerFilePath] string filePath = \"\",\n  [CallerLineNumber] int lineNumber = 0,\n  string message = null)  // Noncompliant\n{\n  /* ... */\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nvoid TraceMessage(string message = null,\n  [CallerMemberName] string memberName = \"\",\n  [CallerFilePath] string filePath = \"\",\n  [CallerLineNumber] int lineNumber = 0)\n{\n  /* ... */\n}\n</pre>",
      "severity": "MAJOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [
        "api-design"
      ],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "5min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "5min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "5min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "5min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S2252",
      "repo": "csharpsquid",
      "name": "For-loop conditions should be true at least once",
      "createdAt": "2019-10-09T08:13:40+0200",
      "htmlDesc": "<p>If a <code>for</code> loop’s condition is false before the first loop iteration, the loop will never be executed. Such loops are almost always\nbugs, particularly when the initial value and stop conditions are hard-coded.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfor (int i &#61; 10; i &lt; 10; i&#43;&#43;)  // Noncompliant\n{\n    // ...\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfor (int i &#61; 0; i &lt; 10; i&#43;&#43;)\n{\n    // ...\n}\n</pre>",
      "mdDesc": "<p>If a <code>for</code> loop’s condition is false before the first loop iteration, the loop will never be executed. Such loops are almost always\nbugs, particularly when the initial value and stop conditions are hard-coded.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfor (int i = 10; i &lt; 10; i++)  // Noncompliant\n{\n    // ...\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfor (int i = 0; i &lt; 10; i++)\n{\n    // ...\n}\n</pre>",
      "severity": "MAJOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "10min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "10min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "10min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "10min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S2251",
      "repo": "csharpsquid",
      "name": "A \"for\" loop update clause should move the counter in the right direction",
      "createdAt": "2019-10-29T09:26:15+0100",
      "htmlDesc": "<p>A <code>for</code> loop with a counter that moves in the wrong direction is not an infinite loop. Because of wraparound, the loop will eventually\nreach its stop condition, but in doing so, it will run many, many more times than anticipated, potentially causing unexpected behavior.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\npublic void DoSomething(string[] strings)\n{\n  for (int i &#61; 0; i &lt; strings.Length; i--)  // Noncompliant\n  {\n    string s &#61; strings[i];  // IndexOutOfRangeException  when i reaches -1\n    // do stuff\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\npublic void DoSomething(string[] strings)\n{\n  for (int i &#61; 0; i &lt; strings.Length; i&#43;&#43;)\n  {\n    string s &#61; strings[i];\n    // do stuff\n  }\n}\n</pre>\n<h2>See</h2>\n<ul><li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/aTdGBQ\" rel=\"nofollow\">CERT, MSC54-J.</a> - Avoid inadvertent wrapping of loop counters </li></ul>",
      "mdDesc": "<p>A <code>for</code> loop with a counter that moves in the wrong direction is not an infinite loop. Because of wraparound, the loop will eventually\nreach its stop condition, but in doing so, it will run many, many more times than anticipated, potentially causing unexpected behavior.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\npublic void DoSomething(string[] strings)\n{\n  for (int i = 0; i &lt; strings.Length; i--)  // Noncompliant\n  {\n    string s = strings[i];  // IndexOutOfRangeException  when i reaches -1\n    // do stuff\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\npublic void DoSomething(string[] strings)\n{\n  for (int i = 0; i &lt; strings.Length; i++)\n  {\n    string s = strings[i];\n    // do stuff\n  }\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/aTdGBQ\">CERT, MSC54-J.</a> - Avoid inadvertent wrapping of loop counters </li>\n</ul>",
      "severity": "MAJOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "5min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "5min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "5min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "5min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S2995",
      "repo": "csharpsquid",
      "name": "\"Object.ReferenceEquals\" should not be used for value types",
      "createdAt": "2015-07-27T14:14:23+0200",
      "htmlDesc": "<p>Using <code>Object.ReferenceEquals</code> to compare the references of two value types simply won’t return the expected results most of the time\nbecause such types are passed by value, not by reference.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\npublic class MyClass\n{\n  private MyStruct myStruct;\n\n  public void DoSomething(MyStruct s1) {\n    int a &#61; 1;\n    int b &#61; 1;\n\n    if (Object.ReferenceEquals(myStruct, s1))  // Noncompliant; this can never be true\n    {\n      // ...\n    }\n    else if (Object.ReferenceEquals(a,b)) // Noncompliant\n    {\n      // ...\n    }\n  }\n}\n</pre>",
      "mdDesc": "<p>Using <code>Object.ReferenceEquals</code> to compare the references of two value types simply won’t return the expected results most of the time\nbecause such types are passed by value, not by reference.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\npublic class MyClass\n{\n  private MyStruct myStruct;\n\n  public void DoSomething(MyStruct s1) {\n    int a = 1;\n    int b = 1;\n\n    if (Object.ReferenceEquals(myStruct, s1))  // Noncompliant; this can never be true\n    {\n      // ...\n    }\n    else if (Object.ReferenceEquals(a,b)) // Noncompliant\n    {\n      // ...\n    }\n  }\n}\n</pre>",
      "severity": "MAJOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "15min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "15min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "15min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "15min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S2997",
      "repo": "csharpsquid",
      "name": "\"IDisposables\" created in a \"using\" statement should not be returned",
      "createdAt": "2015-07-27T14:14:22+0200",
      "htmlDesc": "<p>Typically you want to use <code>using</code> to create a local <code>IDisposable</code> variable; it will trigger disposal of the object when\ncontrol passes out of the block’s scope. The exception to this rule is when your method returns that <code>IDisposable</code>. In that case\n<code>using</code> disposes of the object before the caller can make use of it, likely causing exceptions at runtime. So you should either remove\n<code>using</code> or avoid returning the <code>IDisposable</code>.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\npublic FileStream WriteToFile(string path, string text)\n{\n  using (var fs &#61; File.Create(path)) // Noncompliant\n  {\n    var bytes &#61; Encoding.UTF8.GetBytes(text);\n    fs.Write(bytes, 0, bytes.Length);\n    return fs;\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\npublic FileStream WriteToFile(string path, string text)\n{\n  var fs &#61; File.Create(path);\n  var bytes &#61; Encoding.UTF8.GetBytes(text);\n  fs.Write(bytes, 0, bytes.Length);\n  return fs;\n}\n</pre>",
      "mdDesc": "<p>Typically you want to use <code>using</code> to create a local <code>IDisposable</code> variable; it will trigger disposal of the object when\ncontrol passes out of the block’s scope. The exception to this rule is when your method returns that <code>IDisposable</code>. In that case\n<code>using</code> disposes of the object before the caller can make use of it, likely causing exceptions at runtime. So you should either remove\n<code>using</code> or avoid returning the <code>IDisposable</code>.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\npublic FileStream WriteToFile(string path, string text)\n{\n  using (var fs = File.Create(path)) // Noncompliant\n  {\n    var bytes = Encoding.UTF8.GetBytes(text);\n    fs.Write(bytes, 0, bytes.Length);\n    return fs;\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\npublic FileStream WriteToFile(string path, string text)\n{\n  var fs = File.Create(path);\n  var bytes = Encoding.UTF8.GetBytes(text);\n  fs.Write(bytes, 0, bytes.Length);\n  return fs;\n}\n</pre>",
      "severity": "MAJOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "5min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "5min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "5min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "5min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S3603",
      "repo": "csharpsquid",
      "name": "Methods with \"Pure\" attribute should return a value",
      "createdAt": "2016-05-25T15:32:27+0200",
      "htmlDesc": "<p>Marking a method with the <code>Pure</code> attribute specifies that the method doesn’t make any visible changes; thus, the method should return a\nresult, otherwise the call to the method should be equal to no-operation. So <code>Pure</code> on a <code>void</code> method is either a mistake, or\nthe method doesn’t do any meaningful task.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nclass Person\n{\n  private int age;\n  [Pure] // Noncompliant. In this case the method makes a possibly visible state change\n  void ConfigureAge(int age)\n  {\n    ...\n    this.age &#61; age;\n  }\n  ...\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nclass Person\n{\n  private int age;\n\n  void ConfigureAge(int age)\n  {\n    ...\n    this.age &#61; age;\n  }\n  ...\n}\n</pre>",
      "mdDesc": "<p>Marking a method with the <code>Pure</code> attribute specifies that the method doesn’t make any visible changes; thus, the method should return a\nresult, otherwise the call to the method should be equal to no-operation. So <code>Pure</code> on a <code>void</code> method is either a mistake, or\nthe method doesn’t do any meaningful task.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nclass Person\n{\n  private int age;\n  [Pure] // Noncompliant. In this case the method makes a possibly visible state change\n  void ConfigureAge(int age)\n  {\n    ...\n    this.age = age;\n  }\n  ...\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nclass Person\n{\n  private int age;\n\n  void ConfigureAge(int age)\n  {\n    ...\n    this.age = age;\n  }\n  ...\n}\n</pre>",
      "severity": "MAJOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "5min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "5min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "5min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "5min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S3887",
      "repo": "csharpsquid",
      "name": "Mutable, non-private fields should not be \"readonly\"",
      "createdAt": "2017-04-14T12:33:18+0200",
      "htmlDesc": "<p>Using the <code>readonly</code> keyword on a field means that it can’t be changed after initialization. However, when applied to collections or\narrays, that’s only partly true. <code>readonly</code> enforces that another instance can’t be assigned to the field, but it cannot keep the contents\nfrom being updated. That means that in practice, the field value really can be changed, and the use of <code>readonly</code> on such a field is\nmisleading, and you’re likely to not be getting the behavior you expect.</p>\n<p>This rule raises an issue when a non-private, <code>readonly</code> field is an array or collection.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\npublic class MyClass\n{\n  public readonly string[] strings;  // Noncompliant\n\n  // ...\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\npublic class MyClass\n{\n  public string[] strings;\n\n  // ...\n</pre>\n<p>or</p>\n<pre>\npublic class MyClass\n{\n  public readonly ImmutableArray&lt;string&gt; strings;\n\n  // ...\n</pre>\n<p>or</p>\n<pre>\npublic class MyClass\n{\n  private readonly string[] strings;\n\n  // ...\n</pre>",
      "mdDesc": "<p>Using the <code>readonly</code> keyword on a field means that it can’t be changed after initialization. However, when applied to collections or\narrays, that’s only partly true. <code>readonly</code> enforces that another instance can’t be assigned to the field, but it cannot keep the contents\nfrom being updated. That means that in practice, the field value really can be changed, and the use of <code>readonly</code> on such a field is\nmisleading, and you’re likely to not be getting the behavior you expect.</p>\n<p>This rule raises an issue when a non-private, <code>readonly</code> field is an array or collection.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\npublic class MyClass\n{\n  public readonly string[] strings;  // Noncompliant\n\n  // ...\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\npublic class MyClass\n{\n  public string[] strings;\n\n  // ...\n</pre>\n<p>or</p>\n<pre>\npublic class MyClass\n{\n  public readonly ImmutableArray&lt;string&gt; strings;\n\n  // ...\n</pre>\n<p>or</p>\n<pre>\npublic class MyClass\n{\n  private readonly string[] strings;\n\n  // ...\n</pre>",
      "severity": "MINOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "15min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "15min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "15min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "15min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S2551",
      "repo": "csharpsquid",
      "name": "Shared resources should not be used for locking",
      "createdAt": "2015-07-27T14:14:23+0200",
      "htmlDesc": "<p>Shared resources should not be used for locking as it increases the chance of deadlocks. Any other thread could acquire (or attempt to acquire) the\nsame lock for another unrelated purpose.</p>\n<p>Instead, a dedicated <code>object</code> instance should be used for each shared resource, to avoid deadlocks or lock contention.</p>\n<p>The following objects are considered as shared resources:</p>\n<ul><li> <code>this</code> </li><li> a <code>Type</code> object </li><li> a string literal </li><li> a string instance </li></ul>\n<h2>Noncompliant Code Example</h2>\n<pre>\npublic void MyLockingMethod()\n{\n    lock (this) // Noncompliant\n    {\n        // ...\n    }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nprivate readonly object lockObj &#61; new object();\n\npublic void MyLockingMethod()\n{\n    lock (lockObj)\n    {\n        // ...\n    }\n}\n</pre>\n<h2>See</h2>\n<p><a href=\"https://docs.microsoft.com/en-us/dotnet/standard/threading/managed-threading-best-practices\" rel=\"nofollow\">Microsoft Documentation: Managed Threading\nBest Practices</a></p>",
      "mdDesc": "<p>Shared resources should not be used for locking as it increases the chance of deadlocks. Any other thread could acquire (or attempt to acquire) the\nsame lock for another unrelated purpose.</p>\n<p>Instead, a dedicated <code>object</code> instance should be used for each shared resource, to avoid deadlocks or lock contention.</p>\n<p>The following objects are considered as shared resources:</p>\n<ul>\n  <li> <code>this</code> </li>\n  <li> a <code>Type</code> object </li>\n  <li> a string literal </li>\n  <li> a string instance </li>\n</ul>\n<h2>Noncompliant Code Example</h2>\n<pre>\npublic void MyLockingMethod()\n{\n    lock (this) // Noncompliant\n    {\n        // ...\n    }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nprivate readonly object lockObj = new object();\n\npublic void MyLockingMethod()\n{\n    lock (lockObj)\n    {\n        // ...\n    }\n}\n</pre>\n<h2>See</h2>\n<p><a href=\"https://docs.microsoft.com/en-us/dotnet/standard/threading/managed-threading-best-practices\">Microsoft Documentation: Managed Threading\nBest Practices</a></p>",
      "severity": "CRITICAL",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [
        "multi-threading"
      ],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "15min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "15min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "15min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "15min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S3610",
      "repo": "csharpsquid",
      "name": "Nullable type comparison should not be redundant",
      "createdAt": "2016-05-25T15:32:27+0200",
      "htmlDesc": "<p>Calling <code>GetType()</code> on a nullable object returns the underlying value type. Thus, comparing the returned <code>Type</code> object to\n<code>typeof(Nullable&lt;SomeType&gt;)</code> doesn’t make sense. The comparison either throws an exception or the result can be known at compile\ntime.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint? nullable &#61; 42;\nbool comparison &#61; nullable.GetType() &#61;&#61; typeof(Nullable&lt;int&gt;); // Noncompliant, always false\ncomparison &#61; nullable.GetType() !&#61; typeof(Nullable&lt;int&gt;); // Noncompliant, always true\n\nnullable &#61; null;\ncomparison &#61; nullable.GetType() !&#61; typeof(Nullable&lt;int&gt;); // Noncompliant, calling GetType on a null always throws an exception\n</pre>",
      "mdDesc": "<p>Calling <code>GetType()</code> on a nullable object returns the underlying value type. Thus, comparing the returned <code>Type</code> object to\n<code>typeof(Nullable&lt;SomeType&gt;)</code> doesn’t make sense. The comparison either throws an exception or the result can be known at compile\ntime.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint? nullable = 42;\nbool comparison = nullable.GetType() == typeof(Nullable&lt;int&gt;); // Noncompliant, always false\ncomparison = nullable.GetType() != typeof(Nullable&lt;int&gt;); // Noncompliant, always true\n\nnullable = null;\ncomparison = nullable.GetType() != typeof(Nullable&lt;int&gt;); // Noncompliant, calling GetType on a null always throws an exception\n</pre>",
      "severity": "MAJOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [
        "redundant"
      ],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "5min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "5min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "5min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "5min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S3981",
      "repo": "csharpsquid",
      "name": "Collection sizes and array length comparisons should make sense",
      "createdAt": "2017-06-02T13:36:45+0200",
      "htmlDesc": "<p>The size of a collection and the length of an array are always greater than or equal to zero. So testing that a size or length is greater than or\nequal to zero doesn’t make sense, since the result is always <code>true</code>. Similarly testing that it is less than zero will always return\n<code>false</code>. Perhaps the intent was to check the non-emptiness of the collection or array instead.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nif(collection.Count &gt;&#61; 0){...}\n\nif(enumerable.Count() &lt; 0){...}\n\nif(array.Length &gt;&#61; 0){...}\n\nbool result &#61; array.Length &gt;&#61;0;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nif (list.Any()) { ... }\n\nif (list.Count &gt; 0) { ... }\n\nif (array.Length &gt;&#61; 42) { ... }\n</pre>",
      "mdDesc": "<p>The size of a collection and the length of an array are always greater than or equal to zero. So testing that a size or length is greater than or\nequal to zero doesn’t make sense, since the result is always <code>true</code>. Similarly testing that it is less than zero will always return\n<code>false</code>. Perhaps the intent was to check the non-emptiness of the collection or array instead.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nif(collection.Count &gt;= 0){...}\n\nif(enumerable.Count() &lt; 0){...}\n\nif(array.Length &gt;= 0){...}\n\nbool result = array.Length &gt;=0;\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nif (list.Any()) { ... }\n\nif (list.Count &gt; 0) { ... }\n\nif (array.Length &gt;= 42) { ... }\n</pre>",
      "severity": "MAJOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "2min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "2min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "2min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "2min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S1206",
      "repo": "csharpsquid",
      "name": "\"Equals(Object)\" and \"GetHashCode()\" should be overridden in pairs",
      "createdAt": "2017-04-14T12:33:18+0200",
      "htmlDesc": "<p>There is a contract between <code>Equals(object)</code> and <code>GetHashCode()</code>: If two objects are equal according to the\n<code>Equals(object)</code> method, then calling <code>GetHashCode()</code> on each of them must yield the same result. If this is not the case, many\ncollections won’t handle class instances correctly.</p>\n<p>In order to comply with the contract, <code>Equals(object)</code> and <code>GetHashCode()</code> should be either both inherited, or both\noverridden.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nclass MyClass   // Noncompliant - should also override &#34;GetHashCode()&#34;\n{\n    public override bool Equals(object obj)\n    {\n        // ...\n    }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nclass MyClass\n{\n    public override bool Equals(object obj)\n    {\n        // ...\n    }\n\n    public override int GetHashCode()\n    {\n        // ...\n    }\n}\n</pre>\n<h2>See</h2>\n<ul><li> <a href=\"http://cwe.mitre.org/data/definitions/581.html\" rel=\"nofollow\">MITRE, CWE-581</a> - Object Model Violation: Just One of Equals and Hashcode Defined\n  </li><li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/7DVGBQ\" rel=\"nofollow\">CERT, MET09-J.</a> - Classes that define an equals() method must also define a\n  hashCode() method </li></ul>",
      "mdDesc": "<p>There is a contract between <code>Equals(object)</code> and <code>GetHashCode()</code>: If two objects are equal according to the\n<code>Equals(object)</code> method, then calling <code>GetHashCode()</code> on each of them must yield the same result. If this is not the case, many\ncollections won’t handle class instances correctly.</p>\n<p>In order to comply with the contract, <code>Equals(object)</code> and <code>GetHashCode()</code> should be either both inherited, or both\noverridden.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nclass MyClass   // Noncompliant - should also override \"GetHashCode()\"\n{\n    public override bool Equals(object obj)\n    {\n        // ...\n    }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nclass MyClass\n{\n    public override bool Equals(object obj)\n    {\n        // ...\n    }\n\n    public override int GetHashCode()\n    {\n        // ...\n    }\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/581.html\">MITRE, CWE-581</a> - Object Model Violation: Just One of Equals and Hashcode Defined\n  </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/7DVGBQ\">CERT, MET09-J.</a> - Classes that define an equals() method must also define a\n  hashCode() method </li>\n</ul>",
      "severity": "MINOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [
        "cwe"
      ],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "15min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "15min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "15min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "15min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S3869",
      "repo": "csharpsquid",
      "name": "\"SafeHandle.DangerousGetHandle\" should not be called",
      "createdAt": "2017-04-14T12:33:18+0200",
      "htmlDesc": "<p>Not surprisingly, the <code>SafeHandle.DangerousGetHandle</code> method is dangerous. That’s because it may not return a valid handle. Using it can\nlead to leaks and vulnerabilities. While it is possible to use the method successfully, it’s extremely difficult to do correctly, so the method should\nsimply be avoided altogether.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nstatic void Main(string[] args)\n{\n    System.Reflection.FieldInfo fieldInfo &#61; ...;\n    SafeHandle handle &#61; (SafeHandle)fieldInfo.GetValue(rKey);\n    IntPtr dangerousHandle &#61; handle.DangerousGetHandle();  // Noncompliant\n}\n</pre>",
      "mdDesc": "<p>Not surprisingly, the <code>SafeHandle.DangerousGetHandle</code> method is dangerous. That’s because it may not return a valid handle. Using it can\nlead to leaks and vulnerabilities. While it is possible to use the method successfully, it’s extremely difficult to do correctly, so the method should\nsimply be avoided altogether.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nstatic void Main(string[] args)\n{\n    System.Reflection.FieldInfo fieldInfo = ...;\n    SafeHandle handle = (SafeHandle)fieldInfo.GetValue(rKey);\n    IntPtr dangerousHandle = handle.DangerousGetHandle();  // Noncompliant\n}\n</pre>",
      "severity": "BLOCKER",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [
        "leak",
        "unpredictable"
      ],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "20min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "20min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "20min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "20min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S1862",
      "repo": "csharpsquid",
      "name": "Related \"if/else if\" statements should not have the same condition",
      "createdAt": "2015-05-20T05:01:17+0200",
      "htmlDesc": "<p>A chain of <code>if</code>/<code>else if</code> statements is evaluated from top to bottom. At most, only one branch will be executed: the first\none with a condition that evaluates to <code>true</code>.</p>\n<p>Therefore, duplicating a condition automatically leads to dead code. Usually, this is due to a copy/paste error. At best, it’s simply dead code and\nat worst, it’s a bug that is likely to induce further bugs as the code is maintained, and obviously it could lead to unexpected behavior.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nif (param &#61;&#61; 1)\n{\n  OpenWindow();\n}\nelse if (param &#61;&#61; 2)\n{\n  CloseWindow();\n}\nelse if (param &#61;&#61; 1) // Noncompliant\n{\n  MoveWindowToTheBackground();\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nif (param &#61;&#61; 1)\n{\n  OpenWindow();\n}\nelse if (param &#61;&#61; 2)\n{\n  CloseWindow();\n}\nelse if (param &#61;&#61; 3)\n{\n  MoveWindowToTheBackground();\n}\n</pre>\n<h2>See</h2>\n<ul><li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\" rel=\"nofollow\">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed\n  </li></ul>",
      "mdDesc": "<p>A chain of <code>if</code>/<code>else if</code> statements is evaluated from top to bottom. At most, only one branch will be executed: the first\none with a condition that evaluates to <code>true</code>.</p>\n<p>Therefore, duplicating a condition automatically leads to dead code. Usually, this is due to a copy/paste error. At best, it’s simply dead code and\nat worst, it’s a bug that is likely to induce further bugs as the code is maintained, and obviously it could lead to unexpected behavior.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nif (param == 1)\n{\n  OpenWindow();\n}\nelse if (param == 2)\n{\n  CloseWindow();\n}\nelse if (param == 1) // Noncompliant\n{\n  MoveWindowToTheBackground();\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nif (param == 1)\n{\n  OpenWindow();\n}\nelse if (param == 2)\n{\n  CloseWindow();\n}\nelse if (param == 3)\n{\n  MoveWindowToTheBackground();\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed\n  </li>\n</ul>",
      "severity": "MAJOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [
        "pitfall",
        "unused"
      ],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "10min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "10min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "10min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "10min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S3927",
      "repo": "csharpsquid",
      "name": "Serialization event handlers should be implemented correctly",
      "createdAt": "2017-07-07T12:23:26+0200",
      "htmlDesc": "<p>Serialization event handlers that don’t have the correct signature will simply not be called, thus bypassing any attempts to augment the automated\nde/serialization.</p>\n<p>This rule raises an issue when a method marked with one of the following attributes is <code>public</code>, <code>static</code>, does not return\n<code>void</code>, has type parameters, or does not have a single parameter of type <code>System.Runtime.Serialization.StreamingContext</code>:</p>\n<ul><li> <code>System.Runtime.Serialization.OnSerializingAttribute</code> </li><li> <code>System.Runtime.Serialization.OnSerializedAttribute</code> </li><li> <code>System.Runtime.Serialization.OnDeserializingAttribute</code> </li><li> <code>System.Runtime.Serialization.OnDeserializedAttribute</code> </li></ul>\n<h2>Noncompliant Code Example</h2>\n<pre>\n[Serializable]\npublic class Foo\n{\n    [OnSerializing]\n    public void OnSerializing(StreamingContext context) {} // Noncompliant should be private\n\n    [OnSerialized]\n    int OnSerialized(StreamingContext context) {} // Noncompliant should return void\n\n    [OnDeserializing]\n    void OnDeserializing() {} // Noncompliant should have a single parameter of type StreamingContext\n\n    [OnSerializing]\n    public void OnSerializing2&lt;T&gt;(StreamingContext context) {} // Noncompliant should have no type parameters\n\n    [OnDeserialized]\n    void OnDeserialized(StreamingContext context, string str) {} // Noncompliant should have a single parameter of type StreamingContext\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n[Serializable]\npublic class Foo\n{\n    [OnSerializing]\n    private void OnSerializing(StreamingContext context) {}\n\n    [OnSerialized]\n    private void OnSerialized(StreamingContext context) {}\n\n    [OnDeserializing]\n    private void OnDeserializing(StreamingContext context) {}\n\n    [OnDeserialized]\n    private void OnDeserialized(StreamingContext context) {}\n}\n</pre>",
      "mdDesc": "<p>Serialization event handlers that don’t have the correct signature will simply not be called, thus bypassing any attempts to augment the automated\nde/serialization.</p>\n<p>This rule raises an issue when a method marked with one of the following attributes is <code>public</code>, <code>static</code>, does not return\n<code>void</code>, has type parameters, or does not have a single parameter of type <code>System.Runtime.Serialization.StreamingContext</code>:</p>\n<ul>\n  <li> <code>System.Runtime.Serialization.OnSerializingAttribute</code> </li>\n  <li> <code>System.Runtime.Serialization.OnSerializedAttribute</code> </li>\n  <li> <code>System.Runtime.Serialization.OnDeserializingAttribute</code> </li>\n  <li> <code>System.Runtime.Serialization.OnDeserializedAttribute</code> </li>\n</ul>\n<h2>Noncompliant Code Example</h2>\n<pre>\n[Serializable]\npublic class Foo\n{\n    [OnSerializing]\n    public void OnSerializing(StreamingContext context) {} // Noncompliant should be private\n\n    [OnSerialized]\n    int OnSerialized(StreamingContext context) {} // Noncompliant should return void\n\n    [OnDeserializing]\n    void OnDeserializing() {} // Noncompliant should have a single parameter of type StreamingContext\n\n    [OnSerializing]\n    public void OnSerializing2&lt;T&gt;(StreamingContext context) {} // Noncompliant should have no type parameters\n\n    [OnDeserialized]\n    void OnDeserialized(StreamingContext context, string str) {} // Noncompliant should have a single parameter of type StreamingContext\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n[Serializable]\npublic class Foo\n{\n    [OnSerializing]\n    private void OnSerializing(StreamingContext context) {}\n\n    [OnSerialized]\n    private void OnSerialized(StreamingContext context) {}\n\n    [OnDeserializing]\n    private void OnDeserializing(StreamingContext context) {}\n\n    [OnDeserialized]\n    private void OnDeserialized(StreamingContext context) {}\n}\n</pre>",
      "severity": "MAJOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "15min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "15min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "15min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "15min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S2955",
      "repo": "csharpsquid",
      "name": "Generic parameters not constrained to reference types should not be compared to \"null\"",
      "createdAt": "2015-07-27T14:14:23+0200",
      "htmlDesc": "<p>When constraints have not been applied to restrict a generic type parameter to be a reference type, then a value type, such as a\n<code>struct</code>, could also be passed. In such cases, comparing the type parameter to <code>null</code> would always be false, because a\n<code>struct</code> can be empty, but never <code>null</code>. If a value type is truly what’s expected, then the comparison should use\n<code>default()</code>. If it’s not, then constraints should be added so that no value type can be passed.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nprivate bool IsDefault&lt;T&gt;(T value)\n{\n  if (value &#61;&#61; null) // Noncompliant\n  {\n    // ...\n  }\n  // ...\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nprivate bool IsDefault&lt;T&gt;(T value)\n{\n  if(object.Equals(value, default(T)))\n  {\n    // ...\n  }\n  // ...\n}\n</pre>\n<p>or</p>\n<pre>\nprivate bool IsDefault&lt;T&gt;(T value) where T : class\n{\n  if (value &#61;&#61; null)\n  {\n    // ...\n  }\n  // ...\n}\n</pre>",
      "mdDesc": "<p>When constraints have not been applied to restrict a generic type parameter to be a reference type, then a value type, such as a\n<code>struct</code>, could also be passed. In such cases, comparing the type parameter to <code>null</code> would always be false, because a\n<code>struct</code> can be empty, but never <code>null</code>. If a value type is truly what’s expected, then the comparison should use\n<code>default()</code>. If it’s not, then constraints should be added so that no value type can be passed.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nprivate bool IsDefault&lt;T&gt;(T value)\n{\n  if (value == null) // Noncompliant\n  {\n    // ...\n  }\n  // ...\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nprivate bool IsDefault&lt;T&gt;(T value)\n{\n  if(object.Equals(value, default(T)))\n  {\n    // ...\n  }\n  // ...\n}\n</pre>\n<p>or</p>\n<pre>\nprivate bool IsDefault&lt;T&gt;(T value) where T : class\n{\n  if (value == null)\n  {\n    // ...\n  }\n  // ...\n}\n</pre>",
      "severity": "MINOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "10min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "10min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "10min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "10min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S3923",
      "repo": "csharpsquid",
      "name": "All branches in a conditional structure should not have exactly the same implementation",
      "createdAt": "2018-05-16T12:56:55+0200",
      "htmlDesc": "<p>Having all branches in a <code>switch</code> or <code>if</code> chain with the same implementation is an error. Either a copy-paste error was made\nand something different should be executed, or there shouldn’t be a <code>switch</code>/<code>if</code> chain at all.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nif (b &#61;&#61; 0)  // Noncompliant\n{\n    DoTheThing();\n}\nelse\n{\n    DoTheThing();\n}\n\nint b &#61; a &gt; 12 ? 4 : 4;  // Noncompliant\n\nswitch (i) // Noncompliant\n{\n    case 1:\n        DoSomething();\n        break;\n    case 2:\n        DoSomething();\n        break;\n    case 3:\n        DoSomething();\n        break;\n    default:\n        DoSomething();\n}\n</pre>\n<h2>Exceptions</h2>\n<p>This rule does not apply to <code>if</code> chains without <code>else</code>-s, or to <code>switch</code>-es without <code>default</code>\nclauses.</p>\n<pre>\nif (b &#61;&#61; 0)    //no issue, this could have been done on purpose to make the code more readable\n{\n    DoSomething();\n}\nelse if (b &#61;&#61; 1)\n{\n    DoSomething();\n}\n</pre>",
      "mdDesc": "<p>Having all branches in a <code>switch</code> or <code>if</code> chain with the same implementation is an error. Either a copy-paste error was made\nand something different should be executed, or there shouldn’t be a <code>switch</code>/<code>if</code> chain at all.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nif (b == 0)  // Noncompliant\n{\n    DoTheThing();\n}\nelse\n{\n    DoTheThing();\n}\n\nint b = a &gt; 12 ? 4 : 4;  // Noncompliant\n\nswitch (i) // Noncompliant\n{\n    case 1:\n        DoSomething();\n        break;\n    case 2:\n        DoSomething();\n        break;\n    case 3:\n        DoSomething();\n        break;\n    default:\n        DoSomething();\n}\n</pre>\n<h2>Exceptions</h2>\n<p>This rule does not apply to <code>if</code> chains without <code>else</code>-s, or to <code>switch</code>-es without <code>default</code>\nclauses.</p>\n<pre>\nif (b == 0)    //no issue, this could have been done on purpose to make the code more readable\n{\n    DoSomething();\n}\nelse if (b == 1)\n{\n    DoSomething();\n}\n</pre>",
      "severity": "MAJOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "15min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "15min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "15min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "15min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S2930",
      "repo": "csharpsquid",
      "name": "\"IDisposables\" should be disposed",
      "createdAt": "2015-07-27T14:14:23+0200",
      "htmlDesc": "<p>When writing managed code, you don’t need to worry about allocating or freeing memory: The garbage collector takes care of it. For efficiency\nreasons, some objects such as <code>Bitmap</code> use unmanaged memory, enabling for example the use of pointer arithmetic. Such objects have\npotentially huge unmanaged memory footprints, but will have tiny managed ones. Unfortunately, the garbage collector only sees the tiny managed\nfootprint, and fails to reclaim the unmanaged memory (by calling <code>Bitmap</code>&#39;s finalizer method) in a timely fashion.</p>\n<p>Moreover, memory is not the only system resource which needs to be managed in a timely fashion: The operating system can only handle having so many\nfile descriptors (e.g. <code>FileStream</code>) or sockets (e.g. <code>WebClient</code>) open at any given time. Therefore, it is important to\n<code>Dispose</code> of them as soon as they are no longer needed, rather than relying on the garbage collector to call these objects&#39; finalizers at\nsome nondeterministic point in the future.</p>\n<p>This rule tracks <code>private</code> fields and local variables of the following <code>IDisposable</code> types, which are never disposed, closed,\naliased, returned, or passed to other methods.</p>\n<ul><li> <code>System.IO</code> namespace\n    <ul><li> <code>System.IO.FileStream</code> </li><li> <code>System.IO.StreamReader</code> </li><li> <code>System.IO.StreamWriter</code> </li></ul>  </li><li> <code>System.Net</code> namespace\n    <ul><li> <code>System.Net.WebClient</code> </li></ul>  </li><li> <code>System.Net.Sockets</code> namespace\n    <ul><li> <code>System.Net.Sockets.Socket</code> </li><li> <code>System.Net.Sockets.TcpClient</code> </li><li> <code>System.Net.Sockets.UdpClient</code> </li></ul>  </li><li> <code>System.Drawing</code> namespace\n    <ul><li> <code>System.Drawing.Image</code> </li><li> <code>System.Drawing.Bitmap</code> </li></ul>  </li></ul>\n<p>which are either instantiated directly using the <code>new</code> operator, or using one of the following factory methods:</p>\n<ul><li> <code>System.IO.File.Create()</code> </li><li> <code>System.IO.File.Open()</code> </li><li> <code>System.Drawing.Image.FromFile()</code> </li><li> <code>System.Drawing.Image.FromStream()</code> </li></ul>\n<p>on both private fields and local variables.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\npublic class ResourceHolder\n{\n  private FileStream fs; // Noncompliant; Dispose or Close are never called\n\n  public void OpenResource(string path)\n  {\n    this.fs &#61; new FileStream(path, FileMode.Open);\n  }\n\n  public void WriteToFile(string path, string text)\n  {\n    var fs &#61; new FileStream(path, FileMode.Open); // Noncompliant\n    var bytes &#61; Encoding.UTF8.GetBytes(text);\n    fs.Write(bytes, 0, bytes.Length);\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\npublic class ResourceHolder : IDisposable\n{\n  private FileStream fs;\n\n  public void OpenResource(string path)\n  {\n    this.fs &#61; new FileStream(path, FileMode.Open);\n  }\n\n  public void Dispose()\n  {\n    this.fs.Dispose();\n  }\n\n  public void WriteToFile(string path, string text)\n  {\n    using (var fs &#61; new FileStream(path, FileMode.Open))\n    {\n      var bytes &#61; Encoding.UTF8.GetBytes(text);\n      fs.Write(bytes, 0, bytes.Length);\n    }\n  }\n}\n</pre>\n<h2>Exceptions</h2>\n<p><code>IDisposable</code> variables returned from a method or passed to other methods are ignored, as are local <code>IDisposable</code>s that are\ninitialized with other <code>IDisposable</code>s.</p>\n<pre>\npublic Stream WriteToFile(string path, string text)\n{\n  var fs &#61; new FileStream(path, FileMode.Open); // Compliant, because it is returned\n  var bytes &#61; Encoding.UTF8.GetBytes(text);\n  fs.Write(bytes, 0, bytes.Length);\n  return fs;\n}\n\npublic void ReadFromStream(Stream s)\n{\n  var sr &#61; new StreamReader(s); // Compliant as it would close the underlying stream.\n  // ...\n}\n</pre>\n<h2>See</h2>\n<ul><li> <a href=\"http://cwe.mitre.org/data/definitions/459.html\" rel=\"nofollow\">MITRE, CWE-459</a> - Incomplete Cleanup </li></ul>",
      "mdDesc": "<p>When writing managed code, you don’t need to worry about allocating or freeing memory: The garbage collector takes care of it. For efficiency\nreasons, some objects such as <code>Bitmap</code> use unmanaged memory, enabling for example the use of pointer arithmetic. Such objects have\npotentially huge unmanaged memory footprints, but will have tiny managed ones. Unfortunately, the garbage collector only sees the tiny managed\nfootprint, and fails to reclaim the unmanaged memory (by calling <code>Bitmap</code>'s finalizer method) in a timely fashion.</p>\n<p>Moreover, memory is not the only system resource which needs to be managed in a timely fashion: The operating system can only handle having so many\nfile descriptors (e.g. <code>FileStream</code>) or sockets (e.g. <code>WebClient</code>) open at any given time. Therefore, it is important to\n<code>Dispose</code> of them as soon as they are no longer needed, rather than relying on the garbage collector to call these objects' finalizers at\nsome nondeterministic point in the future.</p>\n<p>This rule tracks <code>private</code> fields and local variables of the following <code>IDisposable</code> types, which are never disposed, closed,\naliased, returned, or passed to other methods.</p>\n<ul>\n  <li> <code>System.IO</code> namespace\n    <ul>\n      <li> <code>System.IO.FileStream</code> </li>\n      <li> <code>System.IO.StreamReader</code> </li>\n      <li> <code>System.IO.StreamWriter</code> </li>\n    </ul>  </li>\n  <li> <code>System.Net</code> namespace\n    <ul>\n      <li> <code>System.Net.WebClient</code> </li>\n    </ul>  </li>\n  <li> <code>System.Net.Sockets</code> namespace\n    <ul>\n      <li> <code>System.Net.Sockets.Socket</code> </li>\n      <li> <code>System.Net.Sockets.TcpClient</code> </li>\n      <li> <code>System.Net.Sockets.UdpClient</code> </li>\n    </ul>  </li>\n  <li> <code>System.Drawing</code> namespace\n    <ul>\n      <li> <code>System.Drawing.Image</code> </li>\n      <li> <code>System.Drawing.Bitmap</code> </li>\n    </ul>  </li>\n</ul>\n<p>which are either instantiated directly using the <code>new</code> operator, or using one of the following factory methods:</p>\n<ul>\n  <li> <code>System.IO.File.Create()</code> </li>\n  <li> <code>System.IO.File.Open()</code> </li>\n  <li> <code>System.Drawing.Image.FromFile()</code> </li>\n  <li> <code>System.Drawing.Image.FromStream()</code> </li>\n</ul>\n<p>on both private fields and local variables.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\npublic class ResourceHolder\n{\n  private FileStream fs; // Noncompliant; Dispose or Close are never called\n\n  public void OpenResource(string path)\n  {\n    this.fs = new FileStream(path, FileMode.Open);\n  }\n\n  public void WriteToFile(string path, string text)\n  {\n    var fs = new FileStream(path, FileMode.Open); // Noncompliant\n    var bytes = Encoding.UTF8.GetBytes(text);\n    fs.Write(bytes, 0, bytes.Length);\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\npublic class ResourceHolder : IDisposable\n{\n  private FileStream fs;\n\n  public void OpenResource(string path)\n  {\n    this.fs = new FileStream(path, FileMode.Open);\n  }\n\n  public void Dispose()\n  {\n    this.fs.Dispose();\n  }\n\n  public void WriteToFile(string path, string text)\n  {\n    using (var fs = new FileStream(path, FileMode.Open))\n    {\n      var bytes = Encoding.UTF8.GetBytes(text);\n      fs.Write(bytes, 0, bytes.Length);\n    }\n  }\n}\n</pre>\n<h2>Exceptions</h2>\n<p><code>IDisposable</code> variables returned from a method or passed to other methods are ignored, as are local <code>IDisposable</code>s that are\ninitialized with other <code>IDisposable</code>s.</p>\n<pre>\npublic Stream WriteToFile(string path, string text)\n{\n  var fs = new FileStream(path, FileMode.Open); // Compliant, because it is returned\n  var bytes = Encoding.UTF8.GetBytes(text);\n  fs.Write(bytes, 0, bytes.Length);\n  return fs;\n}\n\npublic void ReadFromStream(Stream s)\n{\n  var sr = new StreamReader(s); // Compliant as it would close the underlying stream.\n  // ...\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/459.html\">MITRE, CWE-459</a> - Incomplete Cleanup </li>\n</ul>",
      "severity": "BLOCKER",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [
        "cwe",
        "denial-of-service"
      ],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "10min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "10min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "10min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "10min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S2934",
      "repo": "csharpsquid",
      "name": "Property assignments should not be made for \"readonly\" fields not constrained to reference types",
      "createdAt": "2015-07-27T14:14:23+0200",
      "htmlDesc": "<p>While the properties of a <code>readonly</code> reference type field can still be changed after initialization, those of a <code>readonly</code>\nvalue field, such as a <code>struct</code>, cannot.</p>\n<p>If the member could be either a <code>class</code> or a <code>struct</code> then assignment to its properties could be unreliable, working\nsometimes but not others.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\ninterface IPoint\n{\n  int X { get; set; }\n  int Y { get; set; }\n}\n\nclass PointManager&lt;T&gt; where T: IPoint\n{\n  readonly T point;  // this could be a struct\n  public PointManager(T point)\n  {\n    this.point &#61; point;\n  }\n\n  public void MovePointVertically(int newX)\n  {\n    point.X &#61; newX; //Noncompliant; if point is a struct, then nothing happened\n    Console.WriteLine(point.X);\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\ninterface IPoint\n{\n  int X { get; set; }\n  int Y { get; set; }\n}\n\nclass PointManager&lt;T&gt; where T : IPoint\n{\n  readonly T point;  // this could be a struct\n  public PointManager(T point)\n  {\n    this.point &#61; point;\n  }\n\n  public void MovePointVertically(int newX) // assignment has been removed\n  {\n    Console.WriteLine(point.X);\n  }\n}\n</pre>\n<p>or</p>\n<pre>\ninterface IPoint\n{\n  int X { get; set; }\n  int Y { get; set; }\n}\n\nclass PointManager&lt;T&gt; where T : class, IPoint\n{\n  readonly T point;  // this can only be a class\n  public PointManager(T point)\n  {\n    this.point &#61; point;\n  }\n\n  public void MovePointVertically(int newX)\n  {\n    point.X &#61; newX;  // this assignment is guaranteed to work\n    Console.WriteLine(point.X);\n  }\n}\n</pre>",
      "mdDesc": "<p>While the properties of a <code>readonly</code> reference type field can still be changed after initialization, those of a <code>readonly</code>\nvalue field, such as a <code>struct</code>, cannot.</p>\n<p>If the member could be either a <code>class</code> or a <code>struct</code> then assignment to its properties could be unreliable, working\nsometimes but not others.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\ninterface IPoint\n{\n  int X { get; set; }\n  int Y { get; set; }\n}\n\nclass PointManager&lt;T&gt; where T: IPoint\n{\n  readonly T point;  // this could be a struct\n  public PointManager(T point)\n  {\n    this.point = point;\n  }\n\n  public void MovePointVertically(int newX)\n  {\n    point.X = newX; //Noncompliant; if point is a struct, then nothing happened\n    Console.WriteLine(point.X);\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\ninterface IPoint\n{\n  int X { get; set; }\n  int Y { get; set; }\n}\n\nclass PointManager&lt;T&gt; where T : IPoint\n{\n  readonly T point;  // this could be a struct\n  public PointManager(T point)\n  {\n    this.point = point;\n  }\n\n  public void MovePointVertically(int newX) // assignment has been removed\n  {\n    Console.WriteLine(point.X);\n  }\n}\n</pre>\n<p>or</p>\n<pre>\ninterface IPoint\n{\n  int X { get; set; }\n  int Y { get; set; }\n}\n\nclass PointManager&lt;T&gt; where T : class, IPoint\n{\n  readonly T point;  // this can only be a class\n  public PointManager(T point)\n  {\n    this.point = point;\n  }\n\n  public void MovePointVertically(int newX)\n  {\n    point.X = newX;  // this assignment is guaranteed to work\n    Console.WriteLine(point.X);\n  }\n}\n</pre>",
      "severity": "MINOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "20min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "20min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "20min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "20min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S2183",
      "repo": "csharpsquid",
      "name": "Integral numbers should not be shifted by zero or more than their number of bits-1",
      "createdAt": "2017-09-08T12:35:24+0200",
      "htmlDesc": "<p>Shifting an integral number by 0 is equivalent to doing nothing but makes the code confusing for maintainers.</p>\n<p>If the first operand is an <code>int</code> or <code>uint</code> (32-bit quantity), the shift count is given by the low-order five bits of the\nsecond operand. That is, the actual shift count is 0 to 31 bits.</p>\n<p>Note that integral number with a less than 32-bit quantity (e.g. <code>short</code>, <code>ushort</code>…​) are implicitly converted to\n<code>int</code> before the shifting operation and so the rule for <code>int</code>/<code>uint</code> applies.</p>\n<p>If the first operand is a <code>long</code> or <code>ulong</code> (64-bit quantity), the shift count is given by the low-order six bits of the\nsecond operand. That is, the actual shift count is 0 to 63 bits.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\npublic void Main()\n{\n    short s &#61; 1;\n    short shortShift1 &#61; (short)(s &lt;&lt; 0); // Noncompliant\n    short shortShift1 &#61; (short)(s &lt;&lt; 16); // Compliant as short will be cast to int (16 is between 0 and 31)\n    short shortShift3 &#61; (short)(s &lt;&lt; 32); // Noncompliant, this is equivalent to shifting by 1\n\n    int i &#61; 1;\n    int intShift1 &#61; i &lt;&lt; 0; // Noncompliant\n    int intShift2 &#61; i &lt;&lt; 32; // Noncompliant, this is equivalent to shifting by 1\n\n    long lg &#61; 1;\n    long longShift1 &#61; lg &lt;&lt; 0; // Noncompliant\n    long longShift2 &#61; lg &lt;&lt; 64; // Noncompliant, this is equivalent to shifting by 1\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\npublic void Main()\n{\n    short s &#61; 1;\n    short shortShift1 &#61; s;\n    short shortShift1 &#61; (short)(s &lt;&lt; 16);\n    short shortShift3 &#61; (short)(s &lt;&lt; 1);\n\n    int i &#61; 1;\n    var intShift1 &#61; i;\n    var intShift2 &#61; i &lt;&lt; 1;\n\n    long lg &#61; 1;\n    var longShift1 &#61; lg;\n    var longShift2 &#61; lg &lt;&lt; 1;\n}\n</pre>\n<h2>Exceptions</h2>\n<p>This rule doesn’t raise an issue when the shift by zero is obviously for cosmetic reasons:</p>\n<ul><li> When the value shifted is a literal. </li><li> When there is a similar shift at the same position on line before or after. E.g.: </li></ul>\n<pre>\nbytes[loc&#43;0] &#61; (byte)(value &gt;&gt; 8);\nbytes[loc&#43;1] &#61; (byte)(value &gt;&gt; 0);\n</pre>\n<h2>See</h2>\n<ul><li> <a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/bitwise-and-shift-operators#left-shift-operator-\" rel=\"nofollow\">Microsoft\n  documentation - Bitwise and shift operators</a> </li></ul>",
      "mdDesc": "<p>Shifting an integral number by 0 is equivalent to doing nothing but makes the code confusing for maintainers.</p>\n<p>If the first operand is an <code>int</code> or <code>uint</code> (32-bit quantity), the shift count is given by the low-order five bits of the\nsecond operand. That is, the actual shift count is 0 to 31 bits.</p>\n<p>Note that integral number with a less than 32-bit quantity (e.g. <code>short</code>, <code>ushort</code>…​) are implicitly converted to\n<code>int</code> before the shifting operation and so the rule for <code>int</code>/<code>uint</code> applies.</p>\n<p>If the first operand is a <code>long</code> or <code>ulong</code> (64-bit quantity), the shift count is given by the low-order six bits of the\nsecond operand. That is, the actual shift count is 0 to 63 bits.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\npublic void Main()\n{\n    short s = 1;\n    short shortShift1 = (short)(s &lt;&lt; 0); // Noncompliant\n    short shortShift1 = (short)(s &lt;&lt; 16); // Compliant as short will be cast to int (16 is between 0 and 31)\n    short shortShift3 = (short)(s &lt;&lt; 32); // Noncompliant, this is equivalent to shifting by 1\n\n    int i = 1;\n    int intShift1 = i &lt;&lt; 0; // Noncompliant\n    int intShift2 = i &lt;&lt; 32; // Noncompliant, this is equivalent to shifting by 1\n\n    long lg = 1;\n    long longShift1 = lg &lt;&lt; 0; // Noncompliant\n    long longShift2 = lg &lt;&lt; 64; // Noncompliant, this is equivalent to shifting by 1\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\npublic void Main()\n{\n    short s = 1;\n    short shortShift1 = s;\n    short shortShift1 = (short)(s &lt;&lt; 16);\n    short shortShift3 = (short)(s &lt;&lt; 1);\n\n    int i = 1;\n    var intShift1 = i;\n    var intShift2 = i &lt;&lt; 1;\n\n    long lg = 1;\n    var longShift1 = lg;\n    var longShift2 = lg &lt;&lt; 1;\n}\n</pre>\n<h2>Exceptions</h2>\n<p>This rule doesn’t raise an issue when the shift by zero is obviously for cosmetic reasons:</p>\n<ul>\n  <li> When the value shifted is a literal. </li>\n  <li> When there is a similar shift at the same position on line before or after. E.g.: </li>\n</ul>\n<pre>\nbytes[loc+0] = (byte)(value &gt;&gt; 8);\nbytes[loc+1] = (byte)(value &gt;&gt; 0);\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a\n  href=\"https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/bitwise-and-shift-operators#left-shift-operator-\">Microsoft\n  documentation - Bitwise and shift operators</a> </li>\n</ul>",
      "severity": "MINOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "5min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "5min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "5min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "5min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S3168",
      "repo": "csharpsquid",
      "name": "\"async\" methods should not return \"void\"",
      "createdAt": "2015-12-08T16:59:59+0100",
      "htmlDesc": "<p>An <code>async</code> method with a <code>void</code> return type is a &#34;fire and forget&#34; method best reserved for event handlers because there’s no\nway to wait for the method’s execution to complete and respond accordingly. There’s also no way to <code>catch</code> exceptions thrown from the\nmethod.</p>\n<p>Having an <code>async void</code> method that is not an event handler could mean your program works some times and not others because of timing\nissues. Instead, <code>async</code> methods should return <code>Task</code>.</p>\n<p>This rule raises an issue when non-event handler methods are both <code>async</code> and <code>void</code>.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nclass HttpPrinter\n{\n  private string content;\n\n  public async void CallNetwork(string url) //Noncompliant\n  {\n    var client &#61; new HttpClient();\n    var response &#61; await client.GetAsync(url);\n    content &#61; await response.Content.ReadAsStringAsync();\n  }\n\n  public async Task PrintContent(string url)  // works correctly if web request finishes in under 1 second, otherwise content will be null\n  {\n    CallNetwork(url);\n    await Task.Delay(1000);\n    Console.Write(content);\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nclass HttpPrinter\n{\n  private string content;\n\n  public async Task CallNetwork(string url)\n  {\n    var client &#61; new HttpClient();\n    var response &#61; await client.GetAsync(url);\n    content &#61; await response.Content.ReadAsStringAsync();\n  }\n\n  public async Task PrintContent(string url)\n  {\n    await CallNetwork(url); // &lt;----- call changed here. If await is not added warning CS4014 will be triggered\n    await Task.Delay(1000);\n    Console.Write(content);\n  }\n}\n</pre>\n<h2>Exceptions</h2>\n<p>Event handlers, i.e. methods with two arguments, first one matching type <code>object</code> or name <code>sender</code> and the second being or\ninheriting from <code>EventArgs</code>, are ignored.</p>\n<p>Methods named as <code>OnSomething</code> are also ignored.</p>",
      "mdDesc": "<p>An <code>async</code> method with a <code>void</code> return type is a \"fire and forget\" method best reserved for event handlers because there’s no\nway to wait for the method’s execution to complete and respond accordingly. There’s also no way to <code>catch</code> exceptions thrown from the\nmethod.</p>\n<p>Having an <code>async void</code> method that is not an event handler could mean your program works some times and not others because of timing\nissues. Instead, <code>async</code> methods should return <code>Task</code>.</p>\n<p>This rule raises an issue when non-event handler methods are both <code>async</code> and <code>void</code>.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nclass HttpPrinter\n{\n  private string content;\n\n  public async void CallNetwork(string url) //Noncompliant\n  {\n    var client = new HttpClient();\n    var response = await client.GetAsync(url);\n    content = await response.Content.ReadAsStringAsync();\n  }\n\n  public async Task PrintContent(string url)  // works correctly if web request finishes in under 1 second, otherwise content will be null\n  {\n    CallNetwork(url);\n    await Task.Delay(1000);\n    Console.Write(content);\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nclass HttpPrinter\n{\n  private string content;\n\n  public async Task CallNetwork(string url)\n  {\n    var client = new HttpClient();\n    var response = await client.GetAsync(url);\n    content = await response.Content.ReadAsStringAsync();\n  }\n\n  public async Task PrintContent(string url)\n  {\n    await CallNetwork(url); // &lt;----- call changed here. If await is not added warning CS4014 will be triggered\n    await Task.Delay(1000);\n    Console.Write(content);\n  }\n}\n</pre>\n<h2>Exceptions</h2>\n<p>Event handlers, i.e. methods with two arguments, first one matching type <code>object</code> or name <code>sender</code> and the second being or\ninheriting from <code>EventArgs</code>, are ignored.</p>\n<p>Methods named as <code>OnSomething</code> are also ignored.</p>",
      "severity": "MAJOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [
        "async-await",
        "multi-threading"
      ],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "15min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "15min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "15min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "15min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S4583",
      "repo": "csharpsquid",
      "name": "Calls to delegate's method \"BeginInvoke\" should be paired with calls to \"EndInvoke\"",
      "createdAt": "2019-10-09T08:13:40+0200",
      "htmlDesc": "<p>Calling the <code>BeginInvoke</code> method of a delegate will allocate some resources that are only freed-up when <code>EndInvoke</code> is\ncalled. This is why you should always pair <code>BeginInvoke</code> with an <code>EndInvoke</code> to complete your asynchronous call.</p>\n<p>This rule raises an issue when:</p>\n<ul><li> the <code>BeginInvoke</code> method is called without any callback and it is not paired with a call to <code>EndInvoke</code> in the same\n  block. </li><li> a callback with a single parameter of type <code>IAsyncResult</code> doesn’t contain a call to <code>EndInvoke</code>. </li></ul>\n<h2>Noncompliant Code Example</h2>\n<p>BeginInvoke without callback</p>\n<pre>\npublic delegate string AsyncMethodCaller();\n\npublic static void Main()\n{\n    AsyncExample asyncExample &#61; new AsyncExample();\n    AsyncMethodCaller caller &#61; new AsyncMethodCaller(asyncExample.MyMethod);\n\n    // Initiate the asynchronous call.\n    IAsyncResult result &#61; caller.BeginInvoke(null, null); // Noncompliant - not paired with EndInvoke\n}\n</pre>\n<p>BeginInvoke with callback</p>\n<pre>\npublic delegate string AsyncMethodCaller();\n\npublic static void Main()\n{\n    AsyncExample asyncExample &#61; new AsyncExample();\n    AsyncMethodCaller caller &#61; new AsyncMethodCaller(asyncExample.MyMethod);\n\n    IAsyncResult result &#61; caller.BeginInvoke(\n        new AsyncCallback((IAsyncResult ar) &#61;&gt; {}),\n        null); // Noncompliant - not paired with EndInvoke\n}\n</pre>\n<h2>Compliant Solution</h2>\n<p>BeginInvoke without callback</p>\n<pre>\npublic delegate string AsyncMethodCaller();\n\npublic static void Main()\n{\n    AsyncExample asyncExample &#61; new AsyncExample();\n    AsyncMethodCaller caller &#61; new AsyncMethodCaller(asyncExample.MyMethod);\n\n    IAsyncResult result &#61; caller.BeginInvoke(null, null);\n\n    string returnValue &#61; caller.EndInvoke(result);\n}\n</pre>\n<p>BeginInvoke with callback</p>\n<pre>\npublic delegate string AsyncMethodCaller();\n\npublic static void Main()\n{\n    AsyncExample asyncExample &#61; new AsyncExample();\n    AsyncMethodCaller caller &#61; new AsyncMethodCaller(asyncExample.MyMethod);\n\n    IAsyncResult result &#61; caller.BeginInvoke(\n        new AsyncCallback((IAsyncResult ar) &#61;&gt;\n            {\n                // Call EndInvoke to retrieve the results.\n                string returnValue &#61; caller.EndInvoke(ar);\n            }), null);\n}\n</pre>\n<h2>See</h2>\n<p><a href=\"https://docs.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously\" rel=\"nofollow\">Calling\nSynchronous Methods Asynchronously</a></p>",
      "mdDesc": "<p>Calling the <code>BeginInvoke</code> method of a delegate will allocate some resources that are only freed-up when <code>EndInvoke</code> is\ncalled. This is why you should always pair <code>BeginInvoke</code> with an <code>EndInvoke</code> to complete your asynchronous call.</p>\n<p>This rule raises an issue when:</p>\n<ul>\n  <li> the <code>BeginInvoke</code> method is called without any callback and it is not paired with a call to <code>EndInvoke</code> in the same\n  block. </li>\n  <li> a callback with a single parameter of type <code>IAsyncResult</code> doesn’t contain a call to <code>EndInvoke</code>. </li>\n</ul>\n<h2>Noncompliant Code Example</h2>\n<p>BeginInvoke without callback</p>\n<pre>\npublic delegate string AsyncMethodCaller();\n\npublic static void Main()\n{\n    AsyncExample asyncExample = new AsyncExample();\n    AsyncMethodCaller caller = new AsyncMethodCaller(asyncExample.MyMethod);\n\n    // Initiate the asynchronous call.\n    IAsyncResult result = caller.BeginInvoke(null, null); // Noncompliant - not paired with EndInvoke\n}\n</pre>\n<p>BeginInvoke with callback</p>\n<pre>\npublic delegate string AsyncMethodCaller();\n\npublic static void Main()\n{\n    AsyncExample asyncExample = new AsyncExample();\n    AsyncMethodCaller caller = new AsyncMethodCaller(asyncExample.MyMethod);\n\n    IAsyncResult result = caller.BeginInvoke(\n        new AsyncCallback((IAsyncResult ar) =&gt; {}),\n        null); // Noncompliant - not paired with EndInvoke\n}\n</pre>\n<h2>Compliant Solution</h2>\n<p>BeginInvoke without callback</p>\n<pre>\npublic delegate string AsyncMethodCaller();\n\npublic static void Main()\n{\n    AsyncExample asyncExample = new AsyncExample();\n    AsyncMethodCaller caller = new AsyncMethodCaller(asyncExample.MyMethod);\n\n    IAsyncResult result = caller.BeginInvoke(null, null);\n\n    string returnValue = caller.EndInvoke(result);\n}\n</pre>\n<p>BeginInvoke with callback</p>\n<pre>\npublic delegate string AsyncMethodCaller();\n\npublic static void Main()\n{\n    AsyncExample asyncExample = new AsyncExample();\n    AsyncMethodCaller caller = new AsyncMethodCaller(asyncExample.MyMethod);\n\n    IAsyncResult result = caller.BeginInvoke(\n        new AsyncCallback((IAsyncResult ar) =&gt;\n            {\n                // Call EndInvoke to retrieve the results.\n                string returnValue = caller.EndInvoke(ar);\n            }), null);\n}\n</pre>\n<h2>See</h2>\n<p><a href=\"https://docs.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously\">Calling\nSynchronous Methods Asynchronously</a></p>",
      "severity": "CRITICAL",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "15min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "15min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "15min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "15min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S4260",
      "repo": "csharpsquid",
      "name": "\"ConstructorArgument\" parameters should exist in constructors",
      "createdAt": "2017-11-14T07:57:43+0100",
      "htmlDesc": "<p>When creating a custom Markup Extension that accepts parameters in WPF, the <code>ConstructorArgument</code> markup must be used to identify the\ndiscrete properties that match these parameters. However since this is done via a string, the compiler will not notice if there are typos.</p>\n<p>This rule raises an issue when the string argument to <code>ConstructorArgumentAttribute</code> doesn’t match any parameter of any constructor.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nusing System;\n\nnamespace myLibrary\n{\n  public class MyExtension : MarkupExtension\n  {\n    public MyExtension() { }\n\n    public MyExtension(object value1)\n    {\n      Value1 &#61; value1;\n    }\n\n    [ConstructorArgument(&#34;value2&#34;)]   // Noncompliant\n    public object Value1 { get; set; }\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nusing System;\n\nnamespace myLibrary\n{\n  public class MyExtension : MarkupExtension\n  {\n    public MyExtension() { }\n\n    public MyExtension(object value1)\n    {\n      Value1 &#61; value1;\n    }\n\n    [ConstructorArgument(&#34;value1&#34;)]\n    public object Value1 { get; set; }\n  }\n}\n</pre>",
      "mdDesc": "<p>When creating a custom Markup Extension that accepts parameters in WPF, the <code>ConstructorArgument</code> markup must be used to identify the\ndiscrete properties that match these parameters. However since this is done via a string, the compiler will not notice if there are typos.</p>\n<p>This rule raises an issue when the string argument to <code>ConstructorArgumentAttribute</code> doesn’t match any parameter of any constructor.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nusing System;\n\nnamespace myLibrary\n{\n  public class MyExtension : MarkupExtension\n  {\n    public MyExtension() { }\n\n    public MyExtension(object value1)\n    {\n      Value1 = value1;\n    }\n\n    [ConstructorArgument(\"value2\")]   // Noncompliant\n    public object Value1 { get; set; }\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nusing System;\n\nnamespace myLibrary\n{\n  public class MyExtension : MarkupExtension\n  {\n    public MyExtension() { }\n\n    public MyExtension(object value1)\n    {\n      Value1 = value1;\n    }\n\n    [ConstructorArgument(\"value1\")]\n    public object Value1 { get; set; }\n  }\n}\n</pre>",
      "severity": "MAJOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [
        "wpf",
        "xaml"
      ],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "2min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "2min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "2min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "2min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S4159",
      "repo": "csharpsquid",
      "name": "Classes should implement their \"ExportAttribute\" interfaces",
      "createdAt": "2018-02-14T07:15:14+0100",
      "htmlDesc": "<p>In the Attributed Programming Model, the <code>ExportAttribute</code> declares that a part &#34;exports&#34;, or provides to the composition container, an\nobject that fulfills a particular contract. During composition, parts with imports that have matching contracts will have those dependencies filled by\nthe exported object.</p>\n<p>If the type doesn’t implement the interface it is exporting there will be an issue at runtime (either a cast exception or just a container not\nfilled with the exported type) leading to unexpected behaviors/crashes.</p>\n<p>The rule raises an issue when a class doesn’t implement or inherit the type declared in the <code>ExportAttribute</code>.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n[Export(typeof(ISomeType))]\npublic class SomeType // Noncompliant; doesn&#39;t implement &#39;ISomeType&#39;.\n{\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n[Export(typeof(ISomeType))]\npublic class SomeType : ISomeType\n{\n}\n</pre>",
      "mdDesc": "<p>In the Attributed Programming Model, the <code>ExportAttribute</code> declares that a part \"exports\", or provides to the composition container, an\nobject that fulfills a particular contract. During composition, parts with imports that have matching contracts will have those dependencies filled by\nthe exported object.</p>\n<p>If the type doesn’t implement the interface it is exporting there will be an issue at runtime (either a cast exception or just a container not\nfilled with the exported type) leading to unexpected behaviors/crashes.</p>\n<p>The rule raises an issue when a class doesn’t implement or inherit the type declared in the <code>ExportAttribute</code>.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n[Export(typeof(ISomeType))]\npublic class SomeType // Noncompliant; doesn't implement 'ISomeType'.\n{\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n[Export(typeof(ISomeType))]\npublic class SomeType : ISomeType\n{\n}\n</pre>",
      "severity": "BLOCKER",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [
        "mef",
        "pitfall"
      ],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "15min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "15min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "15min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "15min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S4277",
      "repo": "csharpsquid",
      "name": "\"Shared\" parts should not be created with \"new\"",
      "createdAt": "2018-02-14T07:15:14+0100",
      "htmlDesc": "<p>Marking a class with <code>PartCreationPolicy(CreationPolicy.Shared)</code>, which is part of Managed Extensibility Framework (MEF), means that a\nsingle, shared instance of the exported object will be created. Therefore it doesn’t make sense to create new instances using the constructor and it\nwill most likely result in unexpected behaviours.</p>\n<p>This rule raises an issue when a constructor of a class marked shared with a <code>PartCreationPolicyAttribute</code> is invoked.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n[Export(typeof(IFooBar))]\n[PartCreationPolicy(CreationPolicy.Shared)]\npublic class FooBar : IFooBar\n{\n}\n\npublic class Program\n{\n    public static void Main()\n    {\n        var fooBar &#61; new FooBar(); // Noncompliant;\n    }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n[Export(typeof(IFooBar))]\n[PartCreationPolicy(CreationPolicy.Shared)]\npublic class FooBar : IFooBar\n{\n}\n\npublic class Program\n{\n    public static void Main()\n    {\n        var fooBar &#61; serviceProvider.GetService&lt;IFooBar&gt;();\n    }\n}\n</pre>",
      "mdDesc": "<p>Marking a class with <code>PartCreationPolicy(CreationPolicy.Shared)</code>, which is part of Managed Extensibility Framework (MEF), means that a\nsingle, shared instance of the exported object will be created. Therefore it doesn’t make sense to create new instances using the constructor and it\nwill most likely result in unexpected behaviours.</p>\n<p>This rule raises an issue when a constructor of a class marked shared with a <code>PartCreationPolicyAttribute</code> is invoked.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n[Export(typeof(IFooBar))]\n[PartCreationPolicy(CreationPolicy.Shared)]\npublic class FooBar : IFooBar\n{\n}\n\npublic class Program\n{\n    public static void Main()\n    {\n        var fooBar = new FooBar(); // Noncompliant;\n    }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n[Export(typeof(IFooBar))]\n[PartCreationPolicy(CreationPolicy.Shared)]\npublic class FooBar : IFooBar\n{\n}\n\npublic class Program\n{\n    public static void Main()\n    {\n        var fooBar = serviceProvider.GetService&lt;IFooBar&gt;();\n    }\n}\n</pre>",
      "severity": "CRITICAL",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [
        "mef",
        "pitfall"
      ],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "5min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "5min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "5min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "5min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S4158",
      "repo": "csharpsquid",
      "name": "Empty collections should not be accessed or iterated",
      "createdAt": "2017-09-08T12:35:24+0200",
      "htmlDesc": "<p>When a collection is empty it makes no sense to access or iterate it. Doing so anyway is surely an error; either population was accidentally\nomitted or the developer doesn’t understand the situation.</p>\n<p>This rule raises an issue when any use is made of an empty collection other than the following ignored calls: <code>Add</code>,\n<code>AddRange</code>, <code>Equals</code>, <code>GetHashCode</code>.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvar strings &#61; new List&lt;string&gt;();\n\nstrings.Remove(&#34;bar&#34;);  // Noncompliant\n\nif (strings.Contains(&#34;foo&#34;)) {}  // Noncompliant\n\nforeach (var str in strings) {}  // Noncompliant\n</pre>",
      "mdDesc": "<p>When a collection is empty it makes no sense to access or iterate it. Doing so anyway is surely an error; either population was accidentally\nomitted or the developer doesn’t understand the situation.</p>\n<p>This rule raises an issue when any use is made of an empty collection other than the following ignored calls: <code>Add</code>,\n<code>AddRange</code>, <code>Equals</code>, <code>GetHashCode</code>.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nvar strings = new List&lt;string&gt;();\n\nstrings.Remove(\"bar\");  // Noncompliant\n\nif (strings.Contains(\"foo\")) {}  // Noncompliant\n\nforeach (var str in strings) {}  // Noncompliant\n</pre>",
      "severity": "MINOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "15min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "15min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "15min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "15min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S4210",
      "repo": "csharpsquid",
      "name": "Windows Forms entry points should be marked with STAThread",
      "createdAt": "2018-02-14T07:15:14+0100",
      "htmlDesc": "<p>When an assembly uses Windows Forms (classes and interfaces from the <code>System.Windows.Forms</code> namespace) its entry point should be marked\nwith the <code>STAThreadAttribute</code> to indicate that the threading model should be &#34;Single-Threaded Apartment&#34; (STA) which is the only one\nsupported by Windows Forms.</p>\n<p>This rule raises an issue when the entry point (<code>static void Main</code> method) of an assembly using Windows Forms is not marked as STA.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nusing System;\nusing System.Windows.Forms;\n\nnamespace MyLibrary\n{\n    public class MyForm: Form\n    {\n        public MyForm()\n        {\n            this.Text &#61; &#34;Hello World!&#34;;\n        }\n\n        public static void Main()  // Noncompliant\n        {\n            var form &#61; new MyForm();\n            Application.Run(form);\n        }\n    }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nusing System;\nusing System.Windows.Forms;\n\nnamespace MyLibrary\n{\n    public class MyForm: Form\n    {\n        public MyForm()\n        {\n            this.Text &#61; &#34;Hello World!&#34;;\n        }\n\n        [STAThread]\n        public static void Main()\n        {\n            var form &#61; new MyForm();\n            Application.Run(form);\n        }\n    }\n}\n</pre>",
      "mdDesc": "<p>When an assembly uses Windows Forms (classes and interfaces from the <code>System.Windows.Forms</code> namespace) its entry point should be marked\nwith the <code>STAThreadAttribute</code> to indicate that the threading model should be \"Single-Threaded Apartment\" (STA) which is the only one\nsupported by Windows Forms.</p>\n<p>This rule raises an issue when the entry point (<code>static void Main</code> method) of an assembly using Windows Forms is not marked as STA.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nusing System;\nusing System.Windows.Forms;\n\nnamespace MyLibrary\n{\n    public class MyForm: Form\n    {\n        public MyForm()\n        {\n            this.Text = \"Hello World!\";\n        }\n\n        public static void Main()  // Noncompliant\n        {\n            var form = new MyForm();\n            Application.Run(form);\n        }\n    }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nusing System;\nusing System.Windows.Forms;\n\nnamespace MyLibrary\n{\n    public class MyForm: Form\n    {\n        public MyForm()\n        {\n            this.Text = \"Hello World!\";\n        }\n\n        [STAThread]\n        public static void Main()\n        {\n            var form = new MyForm();\n            Application.Run(form);\n        }\n    }\n}\n</pre>",
      "severity": "MAJOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [
        "pitfall",
        "winforms"
      ],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "2min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "2min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "2min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "2min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S2931",
      "repo": "csharpsquid",
      "name": "Classes with \"IDisposable\" members should implement \"IDisposable\"",
      "createdAt": "2015-07-27T14:14:23+0200",
      "htmlDesc": "<p>An <code>IDisposable</code> object should be disposed (there are some rare exceptions where not disposing is fine, most notably <code>Task</code>).\nIf a class has an <code>IDisposable</code> field, there can be two situations:</p>\n<ul><li> The class observes a field that is under the responsibility of another class. </li><li> The class owns the field, and is therefore responsible for calling <code>Dispose</code> on it. </li></ul>\n<p>In the second case, the safest way for the class to ensure <code>Dispose</code> is called is to call it in its own <code>Dispose</code> function,\nand therefore to be itself <code>IDisposable</code>. A class is considered to own an <code>IDisposable</code> field resource if it created the object\nreferenced by the field.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\npublic class ResourceHolder   // Noncompliant; doesn&#39;t implement IDisposable\n{\n  private FileStream fs;  // This member is never Disposed\n  public void OpenResource(string path)\n  {\n    this.fs &#61; new FileStream(path, FileMode.Open); // I create the FileStream, I&#39;m owning it\n  }\n  public void CloseResource()\n  {\n    this.fs.Close();\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\npublic class ResourceHolder : IDisposable\n{\n  private FileStream fs;\n  public void OpenResource(string path)\n  {\n    this.fs &#61; new FileStream(path, FileMode.Open); // I create the FileStream, I&#39;m owning it\n  }\n  public void CloseResource()\n  {\n    this.fs.Close();\n  }\n\n  public void Dispose()\n  {\n    this.fs.Dispose();\n  }\n}\n</pre>\n<h2>See</h2>\n<ul><li> <a href=\"http://cwe.mitre.org/data/definitions/459.html\" rel=\"nofollow\">MITRE, CWE-459</a> - Incomplete Cleanup </li></ul>",
      "mdDesc": "<p>An <code>IDisposable</code> object should be disposed (there are some rare exceptions where not disposing is fine, most notably <code>Task</code>).\nIf a class has an <code>IDisposable</code> field, there can be two situations:</p>\n<ul>\n  <li> The class observes a field that is under the responsibility of another class. </li>\n  <li> The class owns the field, and is therefore responsible for calling <code>Dispose</code> on it. </li>\n</ul>\n<p>In the second case, the safest way for the class to ensure <code>Dispose</code> is called is to call it in its own <code>Dispose</code> function,\nand therefore to be itself <code>IDisposable</code>. A class is considered to own an <code>IDisposable</code> field resource if it created the object\nreferenced by the field.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\npublic class ResourceHolder   // Noncompliant; doesn't implement IDisposable\n{\n  private FileStream fs;  // This member is never Disposed\n  public void OpenResource(string path)\n  {\n    this.fs = new FileStream(path, FileMode.Open); // I create the FileStream, I'm owning it\n  }\n  public void CloseResource()\n  {\n    this.fs.Close();\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\npublic class ResourceHolder : IDisposable\n{\n&nbsp;&nbsp;private FileStream fs;\n&nbsp;&nbsp;public void OpenResource(string path)\n&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;this.fs = new FileStream(path, FileMode.Open); // I create the FileStream, I'm owning it\n&nbsp;&nbsp;}\n&nbsp;&nbsp;public void CloseResource()\n&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;this.fs.Close();\n&nbsp;&nbsp;}\n\n&nbsp;&nbsp;public void Dispose()\n&nbsp;&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;this.fs.Dispose();\n&nbsp;&nbsp;}\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/459.html\">MITRE, CWE-459</a> - Incomplete Cleanup </li>\n</ul>",
      "severity": "BLOCKER",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [
        "cwe",
        "denial-of-service"
      ],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "10min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "10min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "10min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "10min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S2259",
      "repo": "csharpsquid",
      "name": "Null pointers should not be dereferenced",
      "createdAt": "2016-11-07T15:36:18+0100",
      "htmlDesc": "<p>A reference to <code>null</code> should never be dereferenced/accessed. Doing so will cause a <code>NullReferenceException</code> to be thrown. At\nbest, such an exception will cause abrupt program termination. At worst, it could expose debugging information that would be useful to an attacker, or\nit could allow an attacker to bypass security measures.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nobject o &#61; null;\nif (condition)\n{\n  M1(o.ToString()); // Noncompliant, always null\n}\nelse\n{\n  o &#61; new object();\n}\nM2(o.ToString());\n</pre>\n<h2>Exceptions</h2>\n<p>Calls to extension methods are not reported because they can still operate on <code>null</code> values.</p>\n<p>To create a custom null validation method declare an attribute with name <code>ValidatedNotNullAttribute</code> and mark the parameter that is\nvalidated for null in your method declaration with it:</p>\n<pre>\nusing System;\n\npublic sealed class ValidatedNotNullAttribute : Attribute { }\n\npublic static class Guard\n{\n    public static void NotNull&lt;T&gt;([ValidatedNotNull] this T value, string name) where T : class\n    {\n        if (value &#61;&#61; null)\n            throw new ArgumentNullException(name);\n    }\n}\n\npublic static class Utils\n{\n    public static string ToUpper(string value)\n    {\n        Guard.NotNull(value, nameof(value));\n        if (value &#61;&#61; null)\n        {\n            return value.ToString(); // Compliant, this code is not reachable\n        }\n        return value.ToUpper();\n    }\n}\n</pre>\n<h2>See</h2>\n<ul><li> <a href=\"https://cwe.mitre.org/data/definitions/476.html\" rel=\"nofollow\">MITRE, CWE-476</a> - NULL Pointer Dereference </li><li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/QdcxBQ\" rel=\"nofollow\">CERT, EXP34-C.</a> - Do not dereference null pointers </li><li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/aDdGBQ\" rel=\"nofollow\">CERT, EXP01-J.</a> - Do not use a null in a case where an object is required </li></ul>",
      "mdDesc": "<p>A reference to <code>null</code> should never be dereferenced/accessed. Doing so will cause a <code>NullReferenceException</code> to be thrown. At\nbest, such an exception will cause abrupt program termination. At worst, it could expose debugging information that would be useful to an attacker, or\nit could allow an attacker to bypass security measures.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nobject o = null;\nif (condition)\n{\n  M1(o.ToString()); // Noncompliant, always null\n}\nelse\n{\n  o = new object();\n}\nM2(o.ToString());\n</pre>\n<h2>Exceptions</h2>\n<p>Calls to extension methods are not reported because they can still operate on <code>null</code> values.</p>\n<p>To create a custom null validation method declare an attribute with name <code>ValidatedNotNullAttribute</code> and mark the parameter that is\nvalidated for null in your method declaration with it:</p>\n<pre>\nusing System;\n\npublic sealed class ValidatedNotNullAttribute : Attribute { }\n\npublic static class Guard\n{\n    public static void NotNull&lt;T&gt;([ValidatedNotNull] this T value, string name) where T : class\n    {\n        if (value == null)\n            throw new ArgumentNullException(name);\n    }\n}\n\npublic static class Utils\n{\n    public static string ToUpper(string value)\n    {\n        Guard.NotNull(value, nameof(value));\n        if (value == null)\n        {\n            return value.ToString(); // Compliant, this code is not reachable\n        }\n        return value.ToUpper();\n    }\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://cwe.mitre.org/data/definitions/476.html\">MITRE, CWE-476</a> - NULL Pointer Dereference </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/QdcxBQ\">CERT, EXP34-C.</a> - Do not dereference null pointers </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/aDdGBQ\">CERT, EXP01-J.</a> - Do not use a null in a case where an object is required </li>\n</ul>",
      "severity": "MAJOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [
        "cwe"
      ],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "10min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "10min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "10min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "10min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S2583",
      "repo": "csharpsquid",
      "name": "Conditionally executed code should be reachable",
      "createdAt": "2016-11-07T15:36:18+0100",
      "htmlDesc": "<p>Conditional expressions which are always <code>true</code> or <code>false</code> can lead to dead code. Such code is always buggy and should never\nbe used in production.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\npublic void Sample(bool b)\n{\n    bool a &#61; false;\n    if (a) // Noncompliant\n    {\n        DoSomething(); // never executed\n    }\n\n    if (!a || b) // Noncompliant; &#34;!a&#34; is always &#34;true&#34;, &#34;b&#34; is never evaluated\n    {\n        DoSomething();\n    }\n    else\n    {\n        DoSomethingElse(); // never executed\n    }\n\n    var d &#61; &#34;xxx&#34;;\n    var res &#61; d ?? &#34;value&#34;; // Noncompliant, d is always not null, &#34;value&#34; is never used\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\npublic void Sample(bool b)\n{\n    bool a &#61; false;\n    if (Foo(a))\n    {\n        DoSomething();\n    }\n\n    if (b)\n    {\n        DoSomething();\n    }\n    else\n    {\n        DoSomethingElse();\n    }\n\n    var d &#61; &#34;xxx&#34;;\n    var res &#61; d;\n}\n</pre>\n<h2>Exceptions</h2>\n<p>This rule will not raise an issue in either of these cases:</p>\n<ul><li> When the condition is a single <code>const bool</code> </li></ul>\n<pre>\nconst bool debug &#61; false;\n//...\nif (debug)\n{\n  // Print something\n}\n</pre>\n<ul><li> When the condition is the literal <code>true</code> or <code>false</code>. </li></ul>\n<p>In these cases it is obvious the code is as intended.</p>\n<h2>See</h2>\n<ul><li> <a href=\"http://cwe.mitre.org/data/definitions/570.html\" rel=\"nofollow\">MITRE, CWE-570</a> - Expression is Always False </li><li> <a href=\"http://cwe.mitre.org/data/definitions/571\" rel=\"nofollow\">MITRE, CWE-571</a> - Expression is Always True </li><li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\" rel=\"nofollow\">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed\n  </li></ul>",
      "mdDesc": "<p>Conditional expressions which are always <code>true</code> or <code>false</code> can lead to dead code. Such code is always buggy and should never\nbe used in production.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\npublic void Sample(bool b)\n{\n    bool a = false;\n    if (a) // Noncompliant\n    {\n        DoSomething(); // never executed\n    }\n\n    if (!a || b) // Noncompliant; \"!a\" is always \"true\", \"b\" is never evaluated\n    {\n        DoSomething();\n    }\n    else\n    {\n        DoSomethingElse(); // never executed\n    }\n\n    var d = \"xxx\";\n    var res = d ?? \"value\"; // Noncompliant, d is always not null, \"value\" is never used\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\npublic void Sample(bool b)\n{\n    bool a = false;\n    if (Foo(a))\n    {\n        DoSomething();\n    }\n\n    if (b)\n    {\n        DoSomething();\n    }\n    else\n    {\n        DoSomethingElse();\n    }\n\n    var d = \"xxx\";\n    var res = d;\n}\n</pre>\n<h2>Exceptions</h2>\n<p>This rule will not raise an issue in either of these cases:</p>\n<ul>\n  <li> When the condition is a single <code>const bool</code> </li>\n</ul>\n<pre>\nconst bool debug = false;\n//...\nif (debug)\n{\n  // Print something\n}\n</pre>\n<ul>\n  <li> When the condition is the literal <code>true</code> or <code>false</code>. </li>\n</ul>\n<p>In these cases it is obvious the code is as intended.</p>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/570.html\">MITRE, CWE-570</a> - Expression is Always False </li>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/571\">MITRE, CWE-571</a> - Expression is Always True </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed\n  </li>\n</ul>",
      "severity": "MAJOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [
        "cwe",
        "pitfall",
        "suspicious",
        "unused"
      ],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "15min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "15min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "15min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "15min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S1656",
      "repo": "csharpsquid",
      "name": "Variables should not be self-assigned",
      "createdAt": "2015-05-20T05:01:17+0200",
      "htmlDesc": "<p>There is no reason to re-assign a variable to itself. Either this statement is redundant and should be removed, or the re-assignment is a mistake\nand some other value or variable was intended for the assignment instead.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\npublic void SetName(string name)\n{\n  name &#61; name;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\npublic void SetName(string name)\n{\n  this.name &#61; name;\n}\n</pre>\n<h2>See</h2>\n<ul><li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\" rel=\"nofollow\">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed\n  </li></ul>",
      "mdDesc": "<p>There is no reason to re-assign a variable to itself. Either this statement is redundant and should be removed, or the re-assignment is a mistake\nand some other value or variable was intended for the assignment instead.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\npublic void SetName(string name)\n{\n  name = name;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\npublic void SetName(string name)\n{\n  this.name = name;\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed\n  </li>\n</ul>",
      "severity": "MAJOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "3min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "3min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "3min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "3min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S1764",
      "repo": "csharpsquid",
      "name": "Identical expressions should not be used on both sides of a binary operator",
      "createdAt": "2015-05-20T05:01:17+0200",
      "htmlDesc": "<p>Using the same value on either side of a binary operator is almost always a mistake. In the case of logical operators, it is either a copy/paste\nerror and therefore a bug, or it is simply wasted code, and should be simplified. In the case of bitwise operators and most binary mathematical\noperators, having the same value on both sides of an operator yields predictable results, and should be simplified.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nif ( a &#61;&#61; a ) // always true\n{\n  doZ();\n}\nif ( a !&#61; a ) // always false\n{\n  doY();\n}\nif ( a &#61;&#61; b &amp;&amp; a &#61;&#61; b ) // if the first one is true, the second one is too\n{\n  doX();\n}\nif ( a &#61;&#61; b || a &#61;&#61; b ) // if the first one is true, the second one is too\n{\n  doW();\n}\n\nint j &#61; 5 / 5; //always 1\nint k &#61; 5 - 5; // always 0\n\nc.Equals(c);    //always true\nObject.Equals(c, c); //always true\n</pre>\n<h2>Exceptions</h2>\n<p>This rule ignores <code>*</code>, <code>&#43;</code>, <code>&#61;</code>, <code>&lt;&lt;</code>, and <code>&gt;&gt;</code>.</p>\n<h2>See</h2>\n<ul><li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\" rel=\"nofollow\">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed\n  </li><li> <a href=\"/organizations/explore/rules?open&#61;csharpsquid%3AS1656&amp;rule_key&#61;csharpsquid%3AS1656\" rel=\"nofollow\">S1656</a> - Implements a check on <code>&#61;</code>. </li></ul>",
      "mdDesc": "<p>Using the same value on either side of a binary operator is almost always a mistake. In the case of logical operators, it is either a copy/paste\nerror and therefore a bug, or it is simply wasted code, and should be simplified. In the case of bitwise operators and most binary mathematical\noperators, having the same value on both sides of an operator yields predictable results, and should be simplified.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nif ( a == a ) // always true\n{\n  doZ();\n}\nif ( a != a ) // always false\n{\n  doY();\n}\nif ( a == b &amp;&amp; a == b ) // if the first one is true, the second one is too\n{\n  doX();\n}\nif ( a == b || a == b ) // if the first one is true, the second one is too\n{\n  doW();\n}\n\nint j = 5 / 5; //always 1\nint k = 5 - 5; // always 0\n\nc.Equals(c);    //always true\nObject.Equals(c, c); //always true\n</pre>\n<h2>Exceptions</h2>\n<p>This rule ignores <code>*</code>, <code>+</code>, <code>=</code>, <code>&lt;&lt;</code>, and <code>&gt;&gt;</code>.</p>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed\n  </li>\n  <li> {rule:csharpsquid:S1656} - Implements a check on <code>=</code>. </li>\n</ul>",
      "severity": "MAJOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "2min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "2min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "2min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "2min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S2674",
      "repo": "csharpsquid",
      "name": "The length returned from a stream read should be checked",
      "createdAt": "2015-12-08T17:00:00+0100",
      "htmlDesc": "<p>You cannot assume that any given stream reading call will fill the <code>byte[]</code> passed in to the method with the number of bytes requested.\nInstead, you must check the value returned by the read method to see how many bytes were read. Fail to do so, and you introduce a bug that is both\nharmful and difficult to reproduce.</p>\n<p>This rule raises an issue when a <code>Stream.Read</code> or a <code>Stream.ReadAsync</code> method is called, but the return value is not\nchecked.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\npublic void DoSomething(string fileName)\n{\n  using (var stream &#61; File.Open(fileName, FileMode.Open))\n  {\n    var result &#61; new byte[stream.Length];\n    stream.Read(result, 0, (int)stream.Length); // Noncompliant\n    // ... do something with result\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\npublic void DoSomething(string fileName)\n{\n  using (var stream &#61; File.Open(fileName, FileMode.Open))\n  {\n    var buffer &#61; new byte[1024];\n    using (var ms &#61; new MemoryStream())\n    {\n        int read;\n        while ((read &#61; stream.Read(buffer, 0, buffer.Length)) &gt; 0)\n        {\n            ms.Write(buffer, 0, read);\n        }\n        // ... do something with ms\n    }\n  }\n}\n</pre>\n<h2>See</h2>\n<ul><li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/VzdGBQ\" rel=\"nofollow\">CERT, FIO10-J.</a> - Ensure the array is filled when using read() to fill an array </li></ul>",
      "mdDesc": "<p>You cannot assume that any given stream reading call will fill the <code>byte[]</code> passed in to the method with the number of bytes requested.\nInstead, you must check the value returned by the read method to see how many bytes were read. Fail to do so, and you introduce a bug that is both\nharmful and difficult to reproduce.</p>\n<p>This rule raises an issue when a <code>Stream.Read</code> or a <code>Stream.ReadAsync</code> method is called, but the return value is not\nchecked.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\npublic void DoSomething(string fileName)\n{\n  using (var stream = File.Open(fileName, FileMode.Open))\n  {\n    var result = new byte[stream.Length];\n    stream.Read(result, 0, (int)stream.Length); // Noncompliant\n    // ... do something with result\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\npublic void DoSomething(string fileName)\n{\n  using (var stream = File.Open(fileName, FileMode.Open))\n  {\n    var buffer = new byte[1024];\n    using (var ms = new MemoryStream())\n    {\n        int read;\n        while ((read = stream.Read(buffer, 0, buffer.Length)) &gt; 0)\n        {\n            ms.Write(buffer, 0, read);\n        }\n        // ... do something with ms\n    }\n  }\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/VzdGBQ\">CERT, FIO10-J.</a> - Ensure the array is filled when using read() to fill an array </li>\n</ul>",
      "severity": "MINOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "15min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "15min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "15min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "15min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S2184",
      "repo": "csharpsquid",
      "name": "Results of integer division should not be assigned to floating point variables",
      "createdAt": "2016-03-04T14:35:13+0100",
      "htmlDesc": "<p>When division is performed on <code>int</code>s, the result will always be an <code>int</code>. You can assign that result to a\n<code>double</code>, <code>float</code> or <code>decimal</code> with automatic type conversion, but having started as an <code>int</code>, the result\nwill likely not be what you expect. If the result of <code>int</code> division is assigned to a floating-point variable, precision will have been lost\nbefore the assignment. Instead, at least one operand should be cast or promoted to the final type before the operation takes place.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nstatic void Main()\n{\n  decimal dec &#61; 3/2; // Noncompliant\n  Method(3/2); // Noncompliant\n}\n\nstatic void Method(float f) { }\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nstatic void Main()\n{\n  decimal dec &#61; (decimal)3/2;\n  Method(3.0F/2);\n}\n\nstatic void Method(float f) { }\n</pre>\n<h2>See</h2>\n<ul><li> <a href=\"http://cwe.mitre.org/data/definitions/190\" rel=\"nofollow\">MITRE, CWE-190</a> - Integer Overflow or Wraparound </li><li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/AjdGBQ\" rel=\"nofollow\">CERT, NUM50-J.</a> - Convert integers to floating point for floating-point operations\n  </li><li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/I9cxBQ\" rel=\"nofollow\">CERT, INT18-C.</a> - Evaluate integer expressions in a larger size before comparing or\n  assigning to that size </li><li> <a href=\"https://www.sans.org/top25-software-errors/#cat2\" rel=\"nofollow\">SANS Top 25</a> - Risky Resource Management </li></ul>",
      "mdDesc": "<p>When division is performed on <code>int</code>s, the result will always be an <code>int</code>. You can assign that result to a\n<code>double</code>, <code>float</code> or <code>decimal</code> with automatic type conversion, but having started as an <code>int</code>, the result\nwill likely not be what you expect. If the result of <code>int</code> division is assigned to a floating-point variable, precision will have been lost\nbefore the assignment. Instead, at least one operand should be cast or promoted to the final type before the operation takes place.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nstatic void Main()\n{\n  decimal dec = 3/2; // Noncompliant\n  Method(3/2); // Noncompliant\n}\n\nstatic void Method(float f) { }\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nstatic void Main()\n{\n  decimal dec = (decimal)3/2;\n  Method(3.0F/2);\n}\n\nstatic void Method(float f) { }\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/190\">MITRE, CWE-190</a> - Integer Overflow or Wraparound </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/AjdGBQ\">CERT, NUM50-J.</a> - Convert integers to floating point for floating-point operations\n  </li>\n  <li> <a href=\"https://wiki.sei.cmu.edu/confluence/x/I9cxBQ\">CERT, INT18-C.</a> - Evaluate integer expressions in a larger size before comparing or\n  assigning to that size </li>\n  <li> <a href=\"https://www.sans.org/top25-software-errors/#cat2\">SANS Top 25</a> - Risky Resource Management </li>\n</ul>",
      "severity": "MINOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [
        "cwe",
        "overflow",
        "sans-top25-risky"
      ],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "2min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "2min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "2min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "2min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S4586",
      "repo": "csharpsquid",
      "name": "Non-async \"Task/Task<T>\" methods should not return null",
      "createdAt": "2018-05-16T12:56:55+0200",
      "htmlDesc": "<p>Returning <code>null</code> from a non-<code>async</code> <code>Task</code>/<code>Task&lt;T&gt;</code> method will cause a\n<code>NullReferenceException</code> at runtime. This problem can be avoided by returning <code>Task.FromResult&lt;T&gt;(null)</code> instead.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\npublic Task&lt;object&gt; GetFooAsync()\n{\n    return null; // Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\npublic Task&lt;object&gt; GetFooAsync()\n{\n    return Task.FromResult&lt;object&gt;(null);\n}\n</pre>",
      "mdDesc": "<p>Returning <code>null</code> from a non-<code>async</code> <code>Task</code>/<code>Task&lt;T&gt;</code> method will cause a\n<code>NullReferenceException</code> at runtime. This problem can be avoided by returning <code>Task.FromResult&lt;T&gt;(null)</code> instead.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\npublic Task&lt;object&gt; GetFooAsync()\n{\n    return null; // Noncompliant\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\npublic Task&lt;object&gt; GetFooAsync()\n{\n    return Task.FromResult&lt;object&gt;(null);\n}\n</pre>",
      "severity": "CRITICAL",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [
        "async-await"
      ],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "5min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "5min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "5min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "5min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S3984",
      "repo": "csharpsquid",
      "name": "Exceptions should not be created without being thrown",
      "createdAt": "2017-06-02T13:36:45+0200",
      "htmlDesc": "<p>Creating a new <code>Exception</code> without actually throwing it is useless and is probably due to a mistake.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nif (x &lt; 0)\n{\n  new ArgumentException(&#34;x must be nonnegative&#34;);\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nif (x &lt; 0)\n{\n  throw new ArgumentException(&#34;x must be nonnegative&#34;);\n}\n</pre>",
      "mdDesc": "<p>Creating a new <code>Exception</code> without actually throwing it is useless and is probably due to a mistake.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nif (x &lt; 0)\n{\n  new ArgumentException(\"x must be nonnegative\");\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nif (x &lt; 0)\n{\n  throw new ArgumentException(\"x must be nonnegative\");\n}\n</pre>",
      "severity": "MAJOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [
        "error-handling"
      ],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "2min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "2min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "2min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "2min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S4275",
      "repo": "csharpsquid",
      "name": "Getters and setters should access the expected fields",
      "createdAt": "2018-07-18T12:33:17+0200",
      "htmlDesc": "<p>Properties provide a way to enforce encapsulation by providing <code>public</code>, <code>protected</code> or <code>internal</code> methods that\ngive controlled access to <code>private</code> fields. However in classes with multiple fields it is not unusual that cut and paste is used to quickly\ncreate the needed properties, which can result in the wrong field being accessed by a getter or setter.</p>\n<p>This rule raises an issue in any of these cases:</p>\n<ul><li> A setter does not update the field with the corresponding name. </li><li> A getter does not access the field with the corresponding name. </li></ul>\n<p>For simple properties it is better to use <a href=\"https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/auto-implemented-properties\" rel=\"nofollow\">auto-implemented\nproperties</a> (C# 3.0 or later).</p>\n<p>Field and property names are compared as case-insensitive. All underscore characters are ignored.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nclass A\n{\n    private int x;\n    private int y;\n\n    public int X\n    {\n        get { return x; }\n        set { x &#61; value; }\n    }\n\n    public int Y\n    {\n        get { return x; }  // Noncompliant: field &#39;y&#39; is not used in the return value\n        set { x &#61; value; } // Noncompliant: field &#39;y&#39; is not updated\n    }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nclass A\n{\n    private int x;\n    private int y;\n\n    public int X\n    {\n        get { return x; }\n        set { x &#61; value; }\n    }\n\n    public int Y\n    {\n        get { return y; }\n        set { y &#61; value; }\n    }\n}\n</pre>",
      "mdDesc": "<p>Properties provide a way to enforce encapsulation by providing <code>public</code>, <code>protected</code> or <code>internal</code> methods that\ngive controlled access to <code>private</code> fields. However in classes with multiple fields it is not unusual that cut and paste is used to quickly\ncreate the needed properties, which can result in the wrong field being accessed by a getter or setter.</p>\n<p>This rule raises an issue in any of these cases:</p>\n<ul>\n  <li> A setter does not update the field with the corresponding name. </li>\n  <li> A getter does not access the field with the corresponding name. </li>\n</ul>\n<p>For simple properties it is better to use <a\nhref=\"https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/auto-implemented-properties\">auto-implemented\nproperties</a> (C# 3.0 or later).</p>\n<p>Field and property names are compared as case-insensitive. All underscore characters are ignored.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nclass A\n{\n    private int x;\n    private int y;\n\n    public int X\n    {\n        get { return x; }\n        set { x = value; }\n    }\n\n    public int Y\n    {\n        get { return x; }  // Noncompliant: field 'y' is not used in the return value\n        set { x = value; } // Noncompliant: field 'y' is not updated\n    }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nclass A\n{\n    private int x;\n    private int y;\n\n    public int X\n    {\n        get { return x; }\n        set { x = value; }\n    }\n\n    public int Y\n    {\n        get { return y; }\n        set { y = value; }\n    }\n}\n</pre>",
      "severity": "CRITICAL",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [
        "pitfall"
      ],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "5min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "5min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "5min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "5min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S2952",
      "repo": "csharpsquid",
      "name": "Classes should \"Dispose\" of members from the classes' own \"Dispose\" methods",
      "createdAt": "2015-07-27T14:14:23+0200",
      "htmlDesc": "<p>It is possible in an <code>IDisposable</code> to call <code>Dispose</code> on class members from any method, but the contract of\n<code>Dispose</code> is that it will clean up all unmanaged resources. Move disposing of members to some other method, and you risk resource\nleaks.</p>\n<p>This rule also applies for disposable ref structs.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\npublic class ResourceHolder : IDisposable\n{\n  private FileStream fs;\n  public void OpenResource(string path)\n  {\n    this.fs &#61; new FileStream(path, FileMode.Open);\n  }\n  public void CloseResource()\n  {\n    this.fs.Close();\n  }\n\n  public void CleanUp()\n  {\n    this.fs.Dispose(); // Noncompliant; Dispose not called in class&#39; Dispose method\n  }\n\n  public void Dispose()\n  {\n    // method added to satisfy demands of interface\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\npublic class ResourceHolder : IDisposable\n{\n  private FileStream fs;\n  public void OpenResource(string path)\n  {\n    this.fs &#61; new FileStream(path, FileMode.Open);\n  }\n  public void CloseResource()\n  {\n    this.fs.Close();\n  }\n\n  public void Dispose()\n  {\n    this.fs.Dispose();\n  }\n}\n</pre>\n<h2>See</h2>\n<ul><li> <a href=\"http://cwe.mitre.org/data/definitions/459.html\" rel=\"nofollow\">MITRE, CWE-459</a> - Incomplete Cleanup </li></ul>",
      "mdDesc": "<p>It is possible in an <code>IDisposable</code> to call <code>Dispose</code> on class members from any method, but the contract of\n<code>Dispose</code> is that it will clean up all unmanaged resources. Move disposing of members to some other method, and you risk resource\nleaks.</p>\n<p>This rule also applies for disposable ref structs.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\npublic class ResourceHolder : IDisposable\n{\n  private FileStream fs;\n  public void OpenResource(string path)\n  {\n    this.fs = new FileStream(path, FileMode.Open);\n  }\n  public void CloseResource()\n  {\n    this.fs.Close();\n  }\n\n  public void CleanUp()\n  {\n    this.fs.Dispose(); // Noncompliant; Dispose not called in class' Dispose method\n  }\n\n  public void Dispose()\n  {\n    // method added to satisfy demands of interface\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\npublic class ResourceHolder : IDisposable\n{\n  private FileStream fs;\n  public void OpenResource(string path)\n  {\n    this.fs = new FileStream(path, FileMode.Open);\n  }\n  public void CloseResource()\n  {\n    this.fs.Close();\n  }\n\n  public void Dispose()\n  {\n    this.fs.Dispose();\n  }\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"http://cwe.mitre.org/data/definitions/459.html\">MITRE, CWE-459</a> - Incomplete Cleanup </li>\n</ul>",
      "severity": "CRITICAL",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [
        "cwe",
        "denial-of-service"
      ],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "20min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "20min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "20min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "20min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S4143",
      "repo": "csharpsquid",
      "name": "Collection elements should not be replaced unconditionally",
      "createdAt": "2018-07-18T12:33:17+0200",
      "htmlDesc": "<p>It is highly suspicious when a value is saved for a key or index and then unconditionally overwritten. Such replacements are likely errors.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nlist[index] &#61; &#34;value 1&#34;;\nlist[index] &#61; &#34;value 2&#34;;  // Noncompliant\n\ndictionary.Add(key, &#34;value 1&#34;);\ndictionary[key] &#61; &#34;value 2&#34;; // Noncompliant\n</pre>",
      "mdDesc": "<p>It is highly suspicious when a value is saved for a key or index and then unconditionally overwritten. Such replacements are likely errors.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nlist[index] = \"value 1\";\nlist[index] = \"value 2\";  // Noncompliant\n\ndictionary.Add(key, \"value 1\");\ndictionary[key] = \"value 2\"; // Noncompliant\n</pre>",
      "severity": "MAJOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [
        "suspicious"
      ],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "5min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "5min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "5min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "5min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S2857",
      "repo": "csharpsquid",
      "name": "SQL keywords should be delimited by whitespace",
      "createdAt": "2019-10-29T09:26:15+0100",
      "htmlDesc": "<p>Badly formed SQL is likely to cause errors at runtime.</p>\n<p>This rule raises an issue when the spacing around SQL keywords appears to be missing.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nstring select &#61; &#34;SELECT p.fname, p.lname, p.street1, p.street2, p.city, p.state, p.zip&#34; &#43;\n        &#34;FROM person p&#34; &#43;  // Noncompliant; concatenates to: p.zipFROM\n        &#34;WHERE p.id &#61; &#64;ID&#34;;  // Noncompliant; concatenates to: pWHERE\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nstring select &#61; &#34;SELECT p.fname, p.lname, p.street1, p.street2, p.city, p.state, p.zip&#34; &#43;\n    &#34; FROM person p&#34; &#43;\n    &#34; WHERE p.id &#61; &#64;ID&#34;;\n</pre>",
      "mdDesc": "<p>Badly formed SQL is likely to cause errors at runtime.</p>\n<p>This rule raises an issue when the spacing around SQL keywords appears to be missing.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nstring select = \"SELECT p.fname, p.lname, p.street1, p.street2, p.city, p.state, p.zip\" +\n        \"FROM person p\" +  // Noncompliant; concatenates to: p.zipFROM\n        \"WHERE p.id = @ID\";  // Noncompliant; concatenates to: pWHERE\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nstring select = \"SELECT p.fname, p.lname, p.street1, p.street2, p.city, p.state, p.zip\" +\n    \" FROM person p\" +\n    \" WHERE p.id = @ID\";\n</pre>",
      "severity": "BLOCKER",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [
        "sql"
      ],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "2min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "2min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "2min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "2min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S1244",
      "repo": "csharpsquid",
      "name": "Floating point numbers should not be tested for equality",
      "createdAt": "2015-07-27T14:14:23+0200",
      "htmlDesc": "<p>Floating point math is imprecise because of the challenges of storing such values in a binary representation. Even worse, floating point math is\nnot associative; push a <code>float</code> or a <code>double</code> through a series of simple mathematical operations and the answer will be\ndifferent based on the order of those operation because of the rounding that takes place at each step.</p>\n<p>Even simple floating point assignments are not simple:</p>\n<pre>\nfloat f &#61; 0.100000001f; // 0.1\ndouble d &#61; 0.10000000000000001; // 0.1\n</pre>\n<p>(Results will vary based on compiler and compiler settings)</p>\n<p>Therefore, the use of the equality (<code>&#61;&#61;</code>) and inequality (<code>!&#61;</code>) operators on <code>float</code> or <code>double</code> values\nis almost always an error.</p>\n<p>This rule checks for the use of direct and indirect equality/inequality tests on floats and doubles.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfloat myNumber &#61; 3.146f;\nif ( myNumber &#61;&#61; 3.146f ) //Noncompliant. Because of floating point imprecision, this will be false\n{\n  // ...\n}\n\nif (myNumber &lt;&#61; 3.146f &amp;&amp; mNumber &gt;&#61; 3.146f) // Noncompliant indirect equality test\n{\n  // ...\n}\n\nif (myNumber &lt; 4 || myNumber &gt; 4) // Noncompliant indirect inequality test\n{\n  // ...\n}\n</pre>",
      "mdDesc": "<p>Floating point math is imprecise because of the challenges of storing such values in a binary representation. Even worse, floating point math is\nnot associative; push a <code>float</code> or a <code>double</code> through a series of simple mathematical operations and the answer will be\ndifferent based on the order of those operation because of the rounding that takes place at each step.</p>\n<p>Even simple floating point assignments are not simple:</p>\n<pre>\nfloat f = 0.100000001f; // 0.1\ndouble d = 0.10000000000000001; // 0.1\n</pre>\n<p>(Results will vary based on compiler and compiler settings)</p>\n<p>Therefore, the use of the equality (<code>==</code>) and inequality (<code>!=</code>) operators on <code>float</code> or <code>double</code> values\nis almost always an error.</p>\n<p>This rule checks for the use of direct and indirect equality/inequality tests on floats and doubles.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfloat myNumber = 3.146f;\nif ( myNumber == 3.146f ) //Noncompliant. Because of floating point imprecision, this will be false\n{\n  // ...\n}\n\nif (myNumber &lt;= 3.146f &amp;&amp; mNumber &gt;= 3.146f) // Noncompliant indirect equality test\n{\n  // ...\n}\n\nif (myNumber &lt; 4 || myNumber &gt; 4) // Noncompliant indirect inequality test\n{\n  // ...\n}\n</pre>",
      "severity": "MAJOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "5min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "5min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "5min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "5min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S1048",
      "repo": "csharpsquid",
      "name": "Destructors should not throw exceptions",
      "createdAt": "2018-03-12T12:55:37+0100",
      "htmlDesc": "<p>If Finalize or an override of Finalize throws an exception, and the runtime is not hosted by an application that overrides the default policy, the\nruntime terminates the process immediately without graceful cleanup (finally blocks and finalizers are not executed). This behavior ensures process\nintegrity if the finalizer cannot free or destroy resources.</p>\n<p>The rule reports on throw statements used in finalizers.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nclass MyClass\n{\n    ~MyClass()\n    {\n        throw new NotImplementedException(); // Noncompliant\n    }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nclass MyClass\n{\n    ~MyClass()\n    {\n        // no throw\n    }\n}\n</pre>",
      "mdDesc": "<p>If Finalize or an override of Finalize throws an exception, and the runtime is not hosted by an application that overrides the default policy, the\nruntime terminates the process immediately without graceful cleanup (finally blocks and finalizers are not executed). This behavior ensures process\nintegrity if the finalizer cannot free or destroy resources.</p>\n<p>The rule reports on throw statements used in finalizers.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nclass MyClass\n{\n    ~MyClass()\n    {\n        throw new NotImplementedException(); // Noncompliant\n    }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nclass MyClass\n{\n    ~MyClass()\n    {\n        // no throw\n    }\n}\n</pre>",
      "severity": "BLOCKER",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "30min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "30min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "30min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "30min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S1226",
      "repo": "csharpsquid",
      "name": "Method parameters, caught exceptions and foreach variables' initial values should not be ignored",
      "createdAt": "2015-05-20T05:01:17+0200",
      "htmlDesc": "<p>While it is technically correct to assign to parameters from within method bodies, doing so before the parameter value is read is likely a bug.\nInstead, initial values of parameters, caught exceptions, and foreach parameters should be, if not treated as <code>final</code>, then at least read\nbefore reassignment.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\npublic void DoTheThing(string str, int i, List&lt;string&gt; strings)\n{\n  str &#61; i.ToString(i);  // Noncompliant\n\n  foreach (var s in strings)\n  {\n    s &#61; &#34;hello world&#34;;  // Noncompliant\n  }\n}\n</pre>",
      "mdDesc": "<p>While it is technically correct to assign to parameters from within method bodies, doing so before the parameter value is read is likely a bug.\nInstead, initial values of parameters, caught exceptions, and foreach parameters should be, if not treated as <code>final</code>, then at least read\nbefore reassignment.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\npublic void DoTheThing(string str, int i, List&lt;string&gt; strings)\n{\n  str = i.ToString(i);  // Noncompliant\n\n  foreach (var s in strings)\n  {\n    s = \"hello world\";  // Noncompliant\n  }\n}\n</pre>",
      "severity": "MINOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "5min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "5min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "5min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "5min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S2190",
      "repo": "csharpsquid",
      "name": "Recursion should not be infinite",
      "createdAt": "2016-11-07T15:36:18+0100",
      "htmlDesc": "<p>Recursion happens when control enters a loop that has no exit. This can happen a method invokes itself, when a pair of methods invoke each other,\nor when <code>goto</code> statements are used to move between two segments of code. It can be a useful tool, but unless the method includes a\nprovision to break out of the recursion and <code>return</code>, the recursion will continue until the stack overflows and the program crashes.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint Pow(int num, int exponent)   // Noncompliant; no condition under which pow isn&#39;t re-called\n{\n  num &#61; num * Pow(num, exponent-1);\n  return num;  // this is never reached\n}\n\nvoid InternalRecursion(int i)\n{\n  start:\n    goto end;\n  end:\n    goto start; // Noncompliant; there&#39;s no way to break out of this method\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint Pow(int num, int exponent)\n{\n  if (exponent &gt; 1) // recursion now conditional and stop-able\n  {\n    num &#61; num * Pow(num, exponent-1);\n  }\n  return num;\n}\n</pre>",
      "mdDesc": "<p>Recursion happens when control enters a loop that has no exit. This can happen a method invokes itself, when a pair of methods invoke each other,\nor when <code>goto</code> statements are used to move between two segments of code. It can be a useful tool, but unless the method includes a\nprovision to break out of the recursion and <code>return</code>, the recursion will continue until the stack overflows and the program crashes.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint Pow(int num, int exponent)   // Noncompliant; no condition under which pow isn't re-called\n{\n  num = num * Pow(num, exponent-1);\n  return num;  // this is never reached\n}\n\nvoid InternalRecursion(int i)\n{\n  start:\n    goto end;\n  end:\n    goto start; // Noncompliant; there's no way to break out of this method\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint Pow(int num, int exponent)\n{\n  if (exponent &gt; 1) // recursion now conditional and stop-able\n  {\n    num = num * Pow(num, exponent-1);\n  }\n  return num;\n}\n</pre>",
      "severity": "BLOCKER",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [
        "suspicious"
      ],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "30min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "30min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "30min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "30min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S1751",
      "repo": "csharpsquid",
      "name": "Loops with at most one iteration should be refactored",
      "createdAt": "2017-05-05T12:32:51+0200",
      "htmlDesc": "<p>A loop with at most one iteration is equivalent to the use of an <code>if</code> statement to conditionally execute one piece of code. If the\ninitial intention of the author was really to conditionally execute one piece of code, an <code>if</code> statement should be used instead. If that\nwas not the initial intention of the author, the body of the loop should be fixed to use the nested <code>return</code>, <code>break</code> or\n<code>throw</code> statements in a more appropriate way.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfor (int i &#61; 0; i &lt; 10; i&#43;&#43;)\n{\n    Console.WriteLine(i);\n    break;  // Noncompliant, loop only executes once\n}\n...\nforeach (var item in items)\n{\n    return item;  // Noncompliant, loop only executes once\n}\n...\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfor (int i &#61; 0; i &lt; 10; i&#43;&#43;)\n{\n    Console.WriteLine(i);\n}\n...\nvar item &#61; items.FirstOrDefault();\nif (item !&#61; null)\n{\n    return item;\n}\n...\n</pre>",
      "mdDesc": "<p>A loop with at most one iteration is equivalent to the use of an <code>if</code> statement to conditionally execute one piece of code. If the\ninitial intention of the author was really to conditionally execute one piece of code, an <code>if</code> statement should be used instead. If that\nwas not the initial intention of the author, the body of the loop should be fixed to use the nested <code>return</code>, <code>break</code> or\n<code>throw</code> statements in a more appropriate way.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nfor (int i = 0; i &lt; 10; i++)\n{\n    Console.WriteLine(i);\n    break;  // Noncompliant, loop only executes once\n}\n...\nforeach (var item in items)\n{\n    return item;  // Noncompliant, loop only executes once\n}\n...\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nfor (int i = 0; i &lt; 10; i++)\n{\n    Console.WriteLine(i);\n}\n...\nvar item = items.FirstOrDefault();\nif (item != null)\n{\n    return item;\n}\n...\n</pre>",
      "severity": "MAJOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "5min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "5min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "5min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "5min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "common-cs:FailedUnitTests",
      "repo": "common-cs",
      "name": "Failed unit tests should be fixed",
      "createdAt": "2015-10-13T10:34:23+0200",
      "htmlDesc": "Test failures or errors generally indicate that regressions have been introduced. Those tests should be handled as soon as possible to reduce the cost to fix the corresponding regressions.",
      "mdDesc": "Test failures or errors generally indicate that regressions have been introduced. Those tests should be handled as soon as possible to reduce the cost to fix the corresponding regressions.",
      "severity": "MAJOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "LINEAR",
      "defaultDebtRemFnCoeff": "10min",
      "effortToFixDescription": "number of failed tests",
      "debtOverloaded": false,
      "debtRemFnType": "LINEAR",
      "debtRemFnCoeff": "10min",
      "type": "BUG",
      "defaultRemFnType": "LINEAR",
      "defaultRemFnGapMultiplier": "10min",
      "remFnType": "LINEAR",
      "remFnGapMultiplier": "10min",
      "remFnOverloaded": false,
      "gapDescription": "number of failed tests",
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S1848",
      "repo": "csharpsquid",
      "name": "Objects should not be created to be dropped immediately without being used",
      "createdAt": "2015-05-20T05:01:17+0200",
      "htmlDesc": "<p>There is no good reason to create a new object to not do anything with it. Most of the time, this is due to a missing piece of code and so could\nlead to an unexpected behavior in production.</p>\n<p>If it was done on purpose because the constructor has side-effects, then that side-effect code should be moved into a separate, static method and\ncalled directly.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nif (x &lt; 0)\n  new ArgumentException(&#34;x must be nonnegative&#34;);\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nif (x &lt; 0)\n  throw new ArgumentException(&#34;x must be nonnegative&#34;);\n</pre>",
      "mdDesc": "<p>There is no good reason to create a new object to not do anything with it. Most of the time, this is due to a missing piece of code and so could\nlead to an unexpected behavior in production.</p>\n<p>If it was done on purpose because the constructor has side-effects, then that side-effect code should be moved into a separate, static method and\ncalled directly.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nif (x &lt; 0)\n  new ArgumentException(\"x must be nonnegative\");\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nif (x &lt; 0)\n  throw new ArgumentException(\"x must be nonnegative\");\n</pre>",
      "severity": "MAJOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "5min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "5min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "5min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "5min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S2123",
      "repo": "csharpsquid",
      "name": "Values should not be uselessly incremented",
      "createdAt": "2015-07-27T14:14:23+0200",
      "htmlDesc": "<p>A value that is incremented or decremented and then not stored is at best wasted code and at worst a bug.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\npublic int PickNumber()\n{\n  int i &#61; 0;\n  int j &#61; 0;\n\n  i &#61; i&#43;&#43;; // Noncompliant; i is still zero\n\n  return j&#43;&#43;; // Noncompliant; 0 returned\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\npublic int PickNumber()\n{\n  int i &#61; 0;\n  int j &#61; 0;\n\n  i&#43;&#43;;\n  return &#43;&#43;j;\n}\n</pre>",
      "mdDesc": "<p>A value that is incremented or decremented and then not stored is at best wasted code and at worst a bug.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\npublic int PickNumber()\n{\n  int i = 0;\n  int j = 0;\n\n  i = i++; // Noncompliant; i is still zero\n\n  return j++; // Noncompliant; 0 returned\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\npublic int PickNumber()\n{\n  int i = 0;\n  int j = 0;\n\n  i++;\n  return ++j;\n}\n</pre>",
      "severity": "MAJOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [
        "unused"
      ],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "5min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "5min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "5min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "5min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S2328",
      "repo": "csharpsquid",
      "name": "\"GetHashCode\" should not reference mutable fields",
      "createdAt": "2015-07-27T14:14:23+0200",
      "htmlDesc": "<p><code>GetHashCode</code> is used to file an object in a <code>Dictionary</code> or <code>Hashtable</code>. If <code>GetHashCode</code> uses\nnon-<code>readonly</code> fields and those fields change after the object is stored, the object immediately becomes mis-filed in the\n<code>Hashtable</code>. Any subsequent test to see if the object is in the <code>Hashtable</code> will return a false negative.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\npublic class Person\n{\n  public int age;\n  public string name;\n\n  public override int GetHashCode()\n  {\n    int hash &#61; 12;\n    hash &#43;&#61; this.age.GetHashCode(); // Noncompliant\n    hash &#43;&#61; this.name.GetHashCode(); // Noncompliant\n    return hash;\n  }\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\npublic class Person\n{\n  public readonly DateTime birthday;\n  public string name;\n\n  public override int GetHashCode()\n  {\n    int hash &#61; 12;\n    hash &#43;&#61; this.birthday.GetHashCode();\n    return hash;\n  }\n</pre>",
      "mdDesc": "<p><code>GetHashCode</code> is used to file an object in a <code>Dictionary</code> or <code>Hashtable</code>. If <code>GetHashCode</code> uses\nnon-<code>readonly</code> fields and those fields change after the object is stored, the object immediately becomes mis-filed in the\n<code>Hashtable</code>. Any subsequent test to see if the object is in the <code>Hashtable</code> will return a false negative.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\npublic class Person\n{\n  public int age;\n  public string name;\n\n  public override int GetHashCode()\n  {\n    int hash = 12;\n    hash += this.age.GetHashCode(); // Noncompliant\n    hash += this.name.GetHashCode(); // Noncompliant\n    return hash;\n  }\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\npublic class Person\n{\n  public readonly DateTime birthday;\n  public string name;\n\n  public override int GetHashCode()\n  {\n    int hash = 12;\n    hash += this.birthday.GetHashCode();\n    return hash;\n  }\n</pre>",
      "severity": "MINOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "10min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "10min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "10min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "10min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S2761",
      "repo": "csharpsquid",
      "name": "Doubled prefix operators \"!!\" and \"~~\" should not be used",
      "createdAt": "2015-10-02T13:39:15+0200",
      "htmlDesc": "<p>Calling the <code>!</code> or <code>~</code> prefix operator twice does nothing: the second invocation undoes the first. Such mistakes are\ntypically caused by accidentally double-tapping the key in question without noticing.</p>\n<p>Either this is a bug, if the operator was actually meant to be called once, or misleading if done on purpose.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint v1 &#61; 0;\nbool v2 &#61; false;\n\nvar v3 &#61; !!v1; // Noncompliant\nvar v4 &#61; ~~v2; // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint v1 &#61; 0;\nbool v2 &#61; false;\n\nvar v3 &#61; !v1;\nvar v4 &#61; ~v2;\n</pre>",
      "mdDesc": "<p>Calling the <code>!</code> or <code>~</code> prefix operator twice does nothing: the second invocation undoes the first. Such mistakes are\ntypically caused by accidentally double-tapping the key in question without noticing.</p>\n<p>Either this is a bug, if the operator was actually meant to be called once, or misleading if done on purpose.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint v1 = 0;\nbool v2 = false;\n\nvar v3 = !!v1; // Noncompliant\nvar v4 = ~~v2; // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint v1 = 0;\nbool v2 = false;\n\nvar v3 = !v1;\nvar v4 = ~v2;\n</pre>",
      "severity": "MAJOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "5min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "5min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "5min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "5min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S2996",
      "repo": "csharpsquid",
      "name": "\"ThreadStatic\" fields should not be initialized",
      "createdAt": "2015-07-27T14:14:23+0200",
      "htmlDesc": "<p>When an object has a field annotated with <code>ThreadStatic</code>, that field is shared within a given thread, but unique across threads. Since a\nclass&#39; static initializer is only invoked for the first thread created, it also means that only the first thread will have the expected initial\nvalues.</p>\n<p>Instead, allow such fields to be initialized to their default values or make the initialization lazy.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\npublic class Foo\n{\n  [ThreadStatic]\n  public static object PerThreadObject &#61; new object(); // Noncompliant. Will be null in all the threads except the first one.\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\npublic class Foo\n{\n  [ThreadStatic]\n  public static object _perThreadObject;\n  public static object PerThreadObject\n  {\n    get\n    {\n      if (_perThreadObject &#61;&#61; null)\n      {\n        _perThreadObject &#61; new object();\n      }\n      return _perThreadObject;\n    }\n  }\n}\n</pre>",
      "mdDesc": "<p>When an object has a field annotated with <code>ThreadStatic</code>, that field is shared within a given thread, but unique across threads. Since a\nclass' static initializer is only invoked for the first thread created, it also means that only the first thread will have the expected initial\nvalues.</p>\n<p>Instead, allow such fields to be initialized to their default values or make the initialization lazy.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\npublic class Foo\n{\n  [ThreadStatic]\n  public static object PerThreadObject = new object(); // Noncompliant. Will be null in all the threads except the first one.\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\npublic class Foo\n{\n  [ThreadStatic]\n  public static object _perThreadObject;\n  public static object PerThreadObject\n  {\n    get\n    {\n      if (_perThreadObject == null)\n      {\n        _perThreadObject = new object();\n      }\n      return _perThreadObject;\n    }\n  }\n}\n</pre>",
      "severity": "MAJOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [
        "multi-threading"
      ],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "20min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "20min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "20min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "20min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S3172",
      "repo": "csharpsquid",
      "name": "Delegates should not be subtracted",
      "createdAt": "2015-10-02T13:39:15+0200",
      "htmlDesc": "<p>In C#, delegates can be added together to chain their execution, and subtracted to remove their execution from the chain.</p>\n<p>Subtracting a chain of delegates from another one might yield unexpected results as shown hereunder - and is likely to be a bug.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nMyDelegate first, second, third, fourth;\nfirst &#61; () &#61;&gt; Console.Write(&#34;1&#34;);\nsecond &#61; () &#61;&gt; Console.Write(&#34;2&#34;);\nthird &#61; () &#61;&gt; Console.Write(&#34;3&#34;);\nfourth &#61; () &#61;&gt; Console.Write(&#34;4&#34;);\n\nMyDelegate chain1234 &#61; first &#43; second &#43; third &#43; fourth; // Compliant - chain sequence &#61; &#34;1234&#34;\nMyDelegate chain12 &#61; chain1234 - third - fourth; // Compliant - chain sequence &#61; &#34;12&#34;\n\n\nMyDelegate chain14 &#61; first &#43; fourth; // creates a new MyDelegate instance which is a list under the covers\nMyDelegate chain23 &#61; chain1234 - chain14; // Noncompliant; (first &#43; fourth) doesn&#39;t exist in chain1234\n\n\n// The chain sequence of &#34;chain23&#34; will be &#34;1234&#34; instead of &#34;23&#34;!\n// Indeed, the sequence &#34;1234&#34; does not contain the subsequence &#34;14&#34;, so nothing is subtracted\n// (but note that &#34;1234&#34; contains both the &#34;1&#34; and &#34;4&#34; subsequences)\nchain23 &#61; chain1234 - (first &#43; fourth); // Noncompliant\n\nchain23(); // will print &#34;1234&#34;!\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nMyDelegate chain23 &#61; chain1234 - first - fourth; // Compliant - &#34;1&#34; is first removed, followed by &#34;4&#34;\n\nchain23(); // will print &#34;23&#34;\n</pre>",
      "mdDesc": "<p>In C#, delegates can be added together to chain their execution, and subtracted to remove their execution from the chain.</p>\n<p>Subtracting a chain of delegates from another one might yield unexpected results as shown hereunder - and is likely to be a bug.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nMyDelegate first, second, third, fourth;\nfirst = () =&gt; Console.Write(\"1\");\nsecond = () =&gt; Console.Write(\"2\");\nthird = () =&gt; Console.Write(\"3\");\nfourth = () =&gt; Console.Write(\"4\");\n\nMyDelegate chain1234 = first + second + third + fourth; // Compliant - chain sequence = \"1234\"\nMyDelegate chain12 = chain1234 - third - fourth; // Compliant - chain sequence = \"12\"\n\n\nMyDelegate chain14 = first + fourth; // creates a new MyDelegate instance which is a list under the covers\nMyDelegate chain23 = chain1234 - chain14; // Noncompliant; (first + fourth) doesn't exist in chain1234\n\n\n// The chain sequence of \"chain23\" will be \"1234\" instead of \"23\"!\n// Indeed, the sequence \"1234\" does not contain the subsequence \"14\", so nothing is subtracted\n// (but note that \"1234\" contains both the \"1\" and \"4\" subsequences)\nchain23 = chain1234 - (first + fourth); // Noncompliant\n\nchain23(); // will print \"1234\"!\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nMyDelegate chain23 = chain1234 - first - fourth; // Compliant - \"1\" is first removed, followed by \"4\"\n\nchain23(); // will print \"23\"\n</pre>",
      "severity": "MAJOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "30min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "30min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "30min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "30min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S3263",
      "repo": "csharpsquid",
      "name": "Static fields should appear in the order they must be initialized",
      "createdAt": "2015-11-03T15:27:00+0100",
      "htmlDesc": "<p>Static field initializers are executed in the order in which they appear in the class from top to bottom. Thus, placing a static field in a class\nabove the field or fields required for its initialization will yield unexpected results.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nclass MyClass\n{\n  public static int X &#61; Y; // Noncompliant; Y at this time is still assigned default(int), i.e. 0\n  public static int Y &#61; 42;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nclass MyClass\n{\n  public static int Y &#61; 42;\n  public static int X &#61; Y;\n}\n</pre>\n<p>or</p>\n<pre>\nclass MyClass\n{\n  public static int X;\n  public static int Y &#61; 42;\n\n  static MyClass()\n  {\n    X &#61; Y;\n  }\n}\n</pre>",
      "mdDesc": "<p>Static field initializers are executed in the order in which they appear in the class from top to bottom. Thus, placing a static field in a class\nabove the field or fields required for its initialization will yield unexpected results.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nclass MyClass\n{\n  public static int X = Y; // Noncompliant; Y at this time is still assigned default(int), i.e. 0\n  public static int Y = 42;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nclass MyClass\n{\n  public static int Y = 42;\n  public static int X = Y;\n}\n</pre>\n<p>or</p>\n<pre>\nclass MyClass\n{\n  public static int X;\n  public static int Y = 42;\n\n  static MyClass()\n  {\n    X = Y;\n  }\n}\n</pre>",
      "severity": "MAJOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "5min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "5min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "5min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "5min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S3397",
      "repo": "csharpsquid",
      "name": "\"base.Equals\" should not be used to check for reference equality in \"Equals\" if \"base\" is not \"object\"",
      "createdAt": "2015-12-08T17:00:00+0100",
      "htmlDesc": "<p><code>object.Equals()</code> overrides can be optimized by checking first for reference equality between <code>this</code> and the parameter. This\ncheck can be implemented by calling <code>object.ReferenceEquals()</code> or <code>base.Equals()</code>, where <code>base</code> is\n<code>object</code>. However, using <code>base.Equals()</code> is a maintenance hazard because while it works if you extend <code>Object</code>\ndirectly, if you introduce a new base class that overrides <code>Equals</code>, it suddenly stops working.</p>\n<p>This rule raises an issue if <code>base.Equals()</code> is used but <code>base</code> is not <code>object</code>.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nclass Base\n{\n  private int baseField;\n\n  public override bool Equals(object other)\n  {\n    if (base.Equals(other)) // Okay; base is object\n    {\n      return true;\n    }\n\n    return this.baseField &#61;&#61; ((Base)other).baseField;\n  }\n}\n\nclass Derived : Base\n{\n  private int derivedField;\n\n  public override bool Equals(object other)\n  {\n    if (base.Equals(other))  // Noncompliant\n    {\n      return true;\n    }\n\n    return this.derivedField &#61;&#61; ((Derived)other).derivedField;\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nclass Base\n{\n  private int baseField;\n\n  public override bool Equals(object other)\n  {\n    if (object.ReferenceEquals(this, other))  // base.Equals is okay here, but object.ReferenceEquals is better\n    {\n      return true;\n    }\n\n    return this.baseField &#61;&#61; ((Base)other).baseField;\n  }\n}\n\nclass Derived : Base\n{\n  private int derivedField;\n\n  public override bool Equals(object other)\n  {\n    if (object.ReferenceEquals(this, other))\n    {\n      return true;\n    }\n\n    return base.Equals(other) &amp;&amp; this.derivedField &#61;&#61; ((Derived)other).derivedField;\n  }\n}\n</pre>",
      "mdDesc": "<p><code>object.Equals()</code> overrides can be optimized by checking first for reference equality between <code>this</code> and the parameter. This\ncheck can be implemented by calling <code>object.ReferenceEquals()</code> or <code>base.Equals()</code>, where <code>base</code> is\n<code>object</code>. However, using <code>base.Equals()</code> is a maintenance hazard because while it works if you extend <code>Object</code>\ndirectly, if you introduce a new base class that overrides <code>Equals</code>, it suddenly stops working.</p>\n<p>This rule raises an issue if <code>base.Equals()</code> is used but <code>base</code> is not <code>object</code>.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nclass Base\n{\n  private int baseField;\n\n  public override bool Equals(object other)\n  {\n    if (base.Equals(other)) // Okay; base is object\n    {\n      return true;\n    }\n\n    return this.baseField == ((Base)other).baseField;\n  }\n}\n\nclass Derived : Base\n{\n  private int derivedField;\n\n  public override bool Equals(object other)\n  {\n    if (base.Equals(other))  // Noncompliant\n    {\n      return true;\n    }\n\n    return this.derivedField == ((Derived)other).derivedField;\n  }\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nclass Base\n{\n  private int baseField;\n\n  public override bool Equals(object other)\n  {\n    if (object.ReferenceEquals(this, other))  // base.Equals is okay here, but object.ReferenceEquals is better\n    {\n      return true;\n    }\n\n    return this.baseField == ((Base)other).baseField;\n  }\n}\n\nclass Derived : Base\n{\n  private int derivedField;\n\n  public override bool Equals(object other)\n  {\n    if (object.ReferenceEquals(this, other))\n    {\n      return true;\n    }\n\n    return base.Equals(other) &amp;&amp; this.derivedField == ((Derived)other).derivedField;\n  }\n}\n</pre>",
      "severity": "MINOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "5min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "5min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "5min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "5min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S3456",
      "repo": "csharpsquid",
      "name": "\"string.ToCharArray()\" should not be called redundantly",
      "createdAt": "2016-02-17T22:05:07+0100",
      "htmlDesc": "<p><code>ToCharArray</code> can be omitted when the operation on the array could have been done directly on the string, such as when iterating over\nthe characters in a string, and when accessing a character in a string via an array index. In those cases, explicit <code>ToCharArray</code> calls\nshould be omitted.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nstring str &#61; &#34;some string&#34;;\nforeach (var c in str.ToCharArray()) // Noncompliant\n{\n  // ...\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nstring str &#61; &#34;some string&#34;;\nforeach (var c in str)\n{\n  // ...\n}\n</pre>",
      "mdDesc": "<p><code>ToCharArray</code> can be omitted when the operation on the array could have been done directly on the string, such as when iterating over\nthe characters in a string, and when accessing a character in a string via an array index. In those cases, explicit <code>ToCharArray</code> calls\nshould be omitted.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nstring str = \"some string\";\nforeach (var c in str.ToCharArray()) // Noncompliant\n{\n  // ...\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nstring str = \"some string\";\nforeach (var c in str)\n{\n  // ...\n}\n</pre>",
      "severity": "MINOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [
        "clumsy"
      ],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "2min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "2min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "2min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "2min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S3464",
      "repo": "csharpsquid",
      "name": "Type inheritance should not be recursive",
      "createdAt": "2018-02-14T07:15:14+0100",
      "htmlDesc": "<p>Recursion is acceptable in methods, where you can break out of it. But with class types, you end up with code that will compile but not run if you\ntry to instantiate the class.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nclass C1&lt;T&gt;\n{\n}\nclass C2&lt;T&gt; : C1&lt;C2&lt;C2&lt;T&gt;&gt;&gt; // Noncompliant\n{\n}\n\n...\nvar c2 &#61; new C2&lt;int&gt;();\n</pre>",
      "mdDesc": "<p>Recursion is acceptable in methods, where you can break out of it. But with class types, you end up with code that will compile but not run if you\ntry to instantiate the class.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nclass C1&lt;T&gt;\n{\n}\nclass C2&lt;T&gt; : C1&lt;C2&lt;C2&lt;T&gt;&gt;&gt; // Noncompliant\n{\n}\n\n...\nvar c2 = new C2&lt;int&gt;();\n</pre>",
      "severity": "BLOCKER",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "1h",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "1h",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "1h",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "1h",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S3655",
      "repo": "csharpsquid",
      "name": "Empty nullable value should not be accessed",
      "createdAt": "2016-11-07T15:36:18+0100",
      "htmlDesc": "<p>Nullable value types can hold either a value or <code>null</code>. The value held in the nullable type can be accessed with the <code>Value</code>\nproperty, but <code>.Value</code> throws an <code>InvalidOperationException</code> when the value is <code>null</code>. To avoid the exception, a\nnullable type should always be tested before <code>.Value</code> is accessed.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint? nullable &#61; null;\n...\nUseValue(nullable.Value); // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint? nullable &#61; null;\n...\nif (nullable.HasValue)\n{\n  UseValue(nullable.Value);\n}\n</pre>\n<p>or</p>\n<pre>\nint? nullable &#61; null;\n...\nif (nullable !&#61; null)\n{\n  UseValue(nullable.Value);\n}\n</pre>\n<h2>See</h2>\n<ul><li> <a href=\"https://cwe.mitre.org/data/definitions/476.html\" rel=\"nofollow\">MITRE, CWE-476</a> - NULL Pointer Dereference </li></ul>",
      "mdDesc": "<p>Nullable value types can hold either a value or <code>null</code>. The value held in the nullable type can be accessed with the <code>Value</code>\nproperty, but <code>.Value</code> throws an <code>InvalidOperationException</code> when the value is <code>null</code>. To avoid the exception, a\nnullable type should always be tested before <code>.Value</code> is accessed.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nint? nullable = null;\n...\nUseValue(nullable.Value); // Noncompliant\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nint? nullable = null;\n...\nif (nullable.HasValue)\n{\n  UseValue(nullable.Value);\n}\n</pre>\n<p>or</p>\n<pre>\nint? nullable = null;\n...\nif (nullable != null)\n{\n  UseValue(nullable.Value);\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://cwe.mitre.org/data/definitions/476.html\">MITRE, CWE-476</a> - NULL Pointer Dereference </li>\n</ul>",
      "severity": "MAJOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [
        "cwe"
      ],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "10min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "10min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "10min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "10min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S3889",
      "repo": "csharpsquid",
      "name": "Neither \"Thread.Resume\" nor \"Thread.Suspend\" should be used",
      "createdAt": "2017-04-14T12:33:18+0200",
      "htmlDesc": "<p><code>Thread.Suspend</code> and <code>Thread.Resume</code> can give unpredictable results, and both methods have been deprecated. Indeed, if\n<code>Thread.Suspend</code> is not used very carefully, a thread can be suspended while holding a lock, thus leading to a deadlock. Other safer\nsynchronization mechanisms should be used, such as <code>Monitor</code>, <code>Mutex</code>, and <code>Semaphore</code>.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nstatic void Main(string[] args)\n{\n  // ...\n  Thread.CurrentThread.Suspend(); // Noncompliant\n  Thread.CurrentThread.Resume(); // Noncompliant\n}\n</pre>\n<h2>See</h2>\n<ul><li> <a href=\"https://msdn.microsoft.com/en-us/library/system.threading.thread.resume.aspx\" rel=\"nofollow\">Thread.Resume Method ()</a> </li><li> <a href=\"https://msdn.microsoft.com/en-us/library/system.threading.thread.suspend%28v&#61;vs.110%29.aspx\" rel=\"nofollow\">Thread.Suspend Method ()</a> </li></ul>",
      "mdDesc": "<p><code>Thread.Suspend</code> and <code>Thread.Resume</code> can give unpredictable results, and both methods have been deprecated. Indeed, if\n<code>Thread.Suspend</code> is not used very carefully, a thread can be suspended while holding a lock, thus leading to a deadlock. Other safer\nsynchronization mechanisms should be used, such as <code>Monitor</code>, <code>Mutex</code>, and <code>Semaphore</code>.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\nstatic void Main(string[] args)\n{\n  // ...\n  Thread.CurrentThread.Suspend(); // Noncompliant\n  Thread.CurrentThread.Resume(); // Noncompliant\n}\n</pre>\n<h2>See</h2>\n<ul>\n  <li> <a href=\"https://msdn.microsoft.com/en-us/library/system.threading.thread.resume.aspx\">Thread.Resume Method ()</a> </li>\n  <li> <a href=\"https://msdn.microsoft.com/en-us/library/system.threading.thread.suspend(v=vs.110).aspx\">Thread.Suspend Method ()</a> </li>\n</ul>",
      "severity": "BLOCKER",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [
        "multi-threading",
        "unpredictable"
      ],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "20min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "20min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "20min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "20min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S3903",
      "repo": "csharpsquid",
      "name": "Types should be defined in named namespaces",
      "createdAt": "2017-04-14T12:33:18+0200",
      "htmlDesc": "<p>Types are declared in namespaces in order to prevent name collisions and as a way to organize them into the object hierarchy. Types that are\ndefined outside any named namespace are in a global namespace that cannot be referenced in code.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\npublic class Foo // Noncompliant\n{\n}\n\npublic struct Bar // Noncompliant\n{\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nnamespace SomeSpace\n{\n    public class Foo\n    {\n    }\n\n    public struct Bar\n    {\n    }\n}\n</pre>",
      "mdDesc": "<p>Types are declared in namespaces in order to prevent name collisions and as a way to organize them into the object hierarchy. Types that are\ndefined outside any named namespace are in a global namespace that cannot be referenced in code.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\npublic class Foo // Noncompliant\n{\n}\n\npublic struct Bar // Noncompliant\n{\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\nnamespace SomeSpace\n{\n    public class Foo\n    {\n    }\n\n    public struct Bar\n    {\n    }\n}\n</pre>",
      "severity": "MAJOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "5min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "5min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "5min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "5min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    },
    {
      "key": "csharpsquid:S3926",
      "repo": "csharpsquid",
      "name": "Deserialization methods should be provided for \"OptionalField\" members",
      "createdAt": "2017-04-14T12:33:18+0200",
      "htmlDesc": "<p>Fields marked with <code>System.Runtime.Serialization.OptionalFieldAttribute</code> are serialized just like any other field. But such fields are\nignored on deserialization, and retain the default values associated with their types. Therefore, deserialization event handlers should be declared to\nset such fields during the deserialization process.</p>\n<p>This rule raises when at least one field with the <code>System.Runtime.Serialization.OptionalFieldAttribute</code> attribute is declared but one\n(or both) of the following event handlers <code>System.Runtime.Serialization.OnDeserializingAttribute</code> or\n<code>System.Runtime.Serialization.OnDeserializedAttribute</code> are not present.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n[Serializable]\npublic class Foo\n{\n    [OptionalField(VersionAdded &#61; 2)]\n    int optionalField &#61; 5;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n[Serializable]\npublic class Foo\n{\n    [OptionalField(VersionAdded &#61; 2)]\n    int optionalField &#61; 5;\n\n    [OnDeserializing]\n    void OnDeserializing(StreamingContext context)\n    {\n\t    optionalField &#61; 5;\n    }\n\n    [OnDeserialized]\n    void OnDeserialized(StreamingContext context)\n    {\n        // Set optionalField if dependent on other deserialized values.\n    }\n}\n</pre>",
      "mdDesc": "<p>Fields marked with <code>System.Runtime.Serialization.OptionalFieldAttribute</code> are serialized just like any other field. But such fields are\nignored on deserialization, and retain the default values associated with their types. Therefore, deserialization event handlers should be declared to\nset such fields during the deserialization process.</p>\n<p>This rule raises when at least one field with the <code>System.Runtime.Serialization.OptionalFieldAttribute</code> attribute is declared but one\n(or both) of the following event handlers <code>System.Runtime.Serialization.OnDeserializingAttribute</code> or\n<code>System.Runtime.Serialization.OnDeserializedAttribute</code> are not present.</p>\n<h2>Noncompliant Code Example</h2>\n<pre>\n[Serializable]\npublic class Foo\n{\n    [OptionalField(VersionAdded = 2)]\n    int optionalField = 5;\n}\n</pre>\n<h2>Compliant Solution</h2>\n<pre>\n[Serializable]\npublic class Foo\n{\n    [OptionalField(VersionAdded = 2)]\n    int optionalField = 5;\n\n    [OnDeserializing]\n    void OnDeserializing(StreamingContext context)\n    {\n\t    optionalField = 5;\n    }\n\n    [OnDeserialized]\n    void OnDeserialized(StreamingContext context)\n    {\n        // Set optionalField if dependent on other deserialized values.\n    }\n}\n</pre>",
      "severity": "MAJOR",
      "status": "READY",
      "isTemplate": false,
      "tags": [],
      "sysTags": [
        "serialization"
      ],
      "lang": "cs",
      "langName": "C#",
      "params": [],
      "defaultDebtRemFnType": "CONSTANT_ISSUE",
      "defaultDebtRemFnOffset": "10min",
      "debtOverloaded": false,
      "debtRemFnType": "CONSTANT_ISSUE",
      "debtRemFnOffset": "10min",
      "type": "BUG",
      "defaultRemFnType": "CONSTANT_ISSUE",
      "defaultRemFnBaseEffort": "10min",
      "remFnType": "CONSTANT_ISSUE",
      "remFnBaseEffort": "10min",
      "remFnOverloaded": false,
      "scope": "MAIN",
      "isExternal": false
    }
  ]
}